lex = (code) => (
  lexTokens(code, {index: 1, line: 1, lineStart: 0})
);

lexTokens = (code, state) => (
  if(
    state.index | gt(code | length),
    then: $ newStream(
      value: $ {
        type: "EOF",
        value: null,
        text: "",
        line: state.line,
        column: code | length | sub(state.lineStart) | up,
      },
      next: emptyStream,
    ),
    else: $ (
      [token, newState] = lexToken(code, state);
      if(
        token | isNull,
        then: $ lexTokens(code, newState),
        else: $ newStream(
          value: $ token,
          next: $ lexTokens(code, newState),
        ),
      )
    ),
  )
);

lexToken = (code, state) => (
  {index:, line:, lineStart:} = state;
  char = code @ index;
  nextChar = code | at(index | up, default: $ null);
  [token, newState] = char | switch(
    ["\"", $ lexString(code, state)],
    ["`", $ lexRawString(code, state)],
    [| eq("/") | and($ nextChar | eq("/")), $ lexComment(code, state)],
    [| eqOneOf(" ", "\t"), $ lexWhitespace(code, state)],
    [| eq("\r") | and($ nextChar | eq("\n")), $ [null, {index: index | add(2), line: line | up, lineStart: index | add(2)}]],
    ["\n", $ [null, {index: index | up, line: line | up, lineStart: index | up}]],
    ["\r", $ [null, {index: index | up, line: line | up, lineStart: index | up}]],
    ["-", $ lexNumber(code, state)],
    [| isBetween("0", "9"), $ lexNumber(code, state)],
    [| isBetween("A", "Z"), $ lexName(code, state)],
    [| isBetween("a", "z"), $ lexName(code, state)],
    else: $ lexOperator(code, state),
  );
  [token, newState]
);

lexString = (code, state) => (
  {index:, line:, lineStart:} = state;
  startIndex = index;
  quoteStart = index | up;
  [text, contentEnd] = gatherStringContent(code, quoteStart);
  value = getStringValue(text, 1, line, lineStart, "", false);
  if(
    contentEnd | ge(code | length),
    then: $ errorAt("unclosedStringLiteral", code, state, value: ["\"", value] | join),
    else: $ (
      finalText = ["\"", text, "\""] | join;
      finalIndex = contentEnd | add(2);
      token = {
        type: "LITERAL",
        value: value,
        text: finalText,
        line: line,
        column: startIndex | sub(lineStart),
      };
      [token, {index: finalIndex, line: line, lineStart: lineStart}]
    ),
  )
);

gatherStringContent = (code, index) => (
  endIndex = index
  | build(up)
  | withPreviousRunning(
    start: false,
    next: (index, state: isEscaped) => (
      isEscaped | not | and($ code @ index | eq("\\"))
    )
  )
  | while(([isEscaped, index]) => (
    index | le(code | length) | and(
      $ isEscaped | or(
        $ code @ index | eq("\"") | not
      )
    )
  ))
  | last @ 2;
  [code | slice(from: index, to: endIndex), endIndex]
);

getStringValue = (code, index, line, lineStart, value, escaped) => (
  if(
    index | gt(code | length),
    then: $ value,
    else: $ (
      char = code @ index;
      if(
        escaped,
        then: $ (
          if(
            char | eq("u") | and($ code @ (index | up) | eq("{")),
            then: $ lexUnicodeEscape(code, index, value),
            else: $ (
              escapedChar = char | switch(
                ["\"", $ "\""],
                ["\\", $ "\\"],
                ["\/", $ "\/"],
                ["b", $ "\b"],
                ["f", $ "\f"],
                ["n", $ "\n"],
                ["r", $ "\r"],
                ["t", $ "\t"],
                else: $ error("invalidStringLiteral", line:, column: index | sub(lineStart), value: ["\"", code, "\""] | join),
              );
              newValue = [value, escapedChar] | join;
              getStringValue(code, index | up, line, lineStart, newValue, false)
            ),
          )
        ),
        else: $ (
          char | switch(
            ["\\", $ getStringValue(code, index | up, line, lineStart, value, true)],
            ["\"", $ value],
            else: $ (
              newValue = [value, char] | join;
              getStringValue(code, index | up, line, lineStart, newValue, false)
            ),
          )
        ),
      )
    ),
  )
);

lexUnicodeEscape = (code, index, value) => (
  braceStart = index | add(2);
  [hex, hexEnd] = lexHexDigits(code, braceStart, "");
  if(
    code | at(hexEnd, default: $ null) | eq("}"),
    then: $ (
      braceEnd = hexEnd | up;
      codePoint = parseHex(hex);
      char = codePointToString(codePoint);
      finalValue = [value, char] | join;
      finalValue
    ),
    else: $ error("invalidStringLiteral", line: 0, column: 0, value: ["\"", code, "\""] | join),
  )
);

lexHexDigits = (code, index, hex) => (
  if(
    index | gt(code | length),
    then: $ [hex, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")) | or($ char | ge("a") | and($ char | le("f")) | or($ char | ge("A") | and($ char | le("F")))),
        then: $ lexHexDigits(code, index | up, [hex, char] | join),
        else: $ [hex, index],
      )
    ),
  )
);

parseHex = (hex) => (
  parseHexDigits(hex, 1, 0)
);

parseHexDigits = (hex, index, value) => (
  if(
    index | gt(hex | length),
    then: $ value,
    else: $ (
      char = hex @ index;
      charCode = char | toCodePoints | first;
      digit = char | switch(
        [| isBetween("0", "9"), $ charCode | sub("0" | toCodePoints | first)],
        [| isBetween("a", "f"), $ charCode | sub("a" | toCodePoints | first) | add(10)],
        [| isBetween("A", "F"), $ charCode | sub("A" | toCodePoints | first) | add(10)],
        else: $ 0,
      );
      parseHexDigits(hex, index | up, value | mul(16) | add(digit))
    ),
  )
);

codePointToString = (codePoint) => (
  [codePoint] | fromCodePoints
);

lexRawString = (code, state) => (
  {index:, line:, lineStart:} = state;
  startIndex = index;
  backtickStart = index | up;
  [text, contentEnd] = lexRawStringContent(code, backtickStart, "`");
  if(
    contentEnd | gt(code | length),
    then: $ error("unclosedStringLiteral", line:, column: contentEnd | sub(lineStart), value: text),
    else: $ (
      finalText = [text, "`"] | join;
      finalIndex = contentEnd | up;
      value = finalText | slice(from: 2, to: -2);
      token = {
        type: "LITERAL",
        value: value,
        text: finalText,
        line: line,
        column: startIndex | sub(lineStart),
      };
      [token, {index: finalIndex, line: line, lineStart: lineStart}]
    ),
  )
);

lexRawStringContent = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ if(
      code @ index | eq("`"),
      then: $ [text, index],
      else: $ lexRawStringContent(code, index | up, [text, code @ index] | join),
    ),
  )
);

lexComment = (code, state) => (
  {index:, line:, lineStart:} = state;
  commentStart = index | add(2);
  newState = lexCommentContent(code, commentStart, line, lineStart);
  [null, newState]
);

lexCommentContent = (code, index, line, lineStart) => (
  if(
    index | gt(code | length),
    then: $ {index: index, line: line, lineStart: lineStart},
    else: $ (
      char = code @ index;
      if(
        char | eq("\r") | and($ code @ (index | up) | eq("\n")),
        then: $ {index: index | add(2), line: line | up, lineStart: index | add(2)},
        else: $ if(
          char | eq("\n") | or($ char | eq("\r")),
          then: $ {index: index | up, line: line | up, lineStart: index | up},
          else: $ lexCommentContent(code, index | up, line, lineStart),
        ),
      )
    ),
  )
);

lexWhitespace = (code, state) => (
  {index:, line:, lineStart:} = state;
  [endIndex] = lexWhitespaceContent(code, index);
  [null, {index: endIndex, line: line, lineStart: lineStart}]
);

lexWhitespaceContent = (code, index) => (
  if(
    index | gt(code | length),
    then: $ [index],
    else: $ if(
      code @ index | eq(" ") | or($ code @ index | eq("\t")),
      then: $ lexWhitespaceContent(code, index | up),
      else: $ [index],
    ),
  )
);

lexNumber = (code, state) => (
  {index:, line:, lineStart:} = state;
  startIndex = index;
  negative = code @ index | eq("-");
  [numberStart, initialText] = if(
    negative,
    then: $ [index | up, "-"],
    else: $ [index, ""],
  );
  [textAfterInt, intEnd] = lexInteger(code, numberStart, initialText);
  [textAfterDecimal, decimalEnd] = lexDecimalPart(code, intEnd, textAfterInt);
  [finalText, exponentEnd] = lexExponentPart(code, decimalEnd, textAfterDecimal);
  value = parseNumber(finalText);
  token = {
    type: "LITERAL",
    value: value,
    text: finalText,
    line: line,
    column: startIndex | sub(lineStart),
  };
  [token, {index: exponentEnd, line: line, lineStart: lineStart}]
);

lexInteger = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | eq("0"),
        then: $ [[text, "0"] | join, index | up],
        else: $ if(
          char | ge("1") | and($ char | le("9")),
          then: $ lexIntegerDigits(code, index | up, [text, char] | join),
          else: $ [text, index],
        ),
      )
    ),
  )
);

lexIntegerDigits = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")),
        then: $ lexIntegerDigits(code, index | up, [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

lexDecimalPart = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ if(
      code @ index | eq("."),
      then: $ (
        textWithDot = [text, "."] | join;
        dotEnd = index | up;
        lexDecimalDigits(code, dotEnd, textWithDot)
      ),
      else: $ [text, index],
    ),
  )
);

lexDecimalDigits = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")),
        then: $ lexDecimalDigits(code, index | up, [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

lexExponentPart = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | eq("e") | or($ char | eq("E")),
        then: $ (
          textWithE = [text, char] | join;
          eEnd = index | up;
          [textAfterSign, signEnd] = lexExponentSign(code, eEnd, textWithE);
          lexExponentDigits(code, signEnd, textAfterSign)
        ),
        else: $ [text, index],
      )
    ),
  )
);

lexExponentSign = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | eq("+") | or($ char | eq("-")),
        then: $ [[text, char] | join, index | up],
        else: $ [text, index],
      )
    ),
  )
);

lexExponentDigits = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")),
        then: $ lexExponentDigits(code, index | up, [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

parseNumber = (text) => (
  text | toNumber
);

lexName = (code, state) => (
  {index:, line:, lineStart:} = state;
  startIndex = index;
  [text, nameEnd] = lexNameContent(code, index, "");
  [kind, value] = text | switch(
    ["null", $ ["LITERAL", null]],
    ["false", $ ["LITERAL", false]],
    ["true", $ ["LITERAL", true]],
    else: $ ["NAME", null],
  );
  token = {
    type: kind,
    value: value,
    text: text,
    line: line,
    column: startIndex | sub(lineStart),
  };
  [token, {index: nameEnd, line: line, lineStart: lineStart}]
);

lexNameContent = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("A") | and($ char | le("Z")) | or($ char | ge("a") | and($ char | le("z")) | or($ char | ge("0") | and($ char | le("9")))),
        then: $ lexNameContent(code, index | up, [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

lexOperator = (code, state) => (
  {index:, line:, lineStart:} = state;
  nextChar = code | at(index | up, default: $ null);
  [token, newState] = code @ index | switch(
    ["(", $ makeToken("OPEN_PAREN", "(", state)],
    [")", $ makeToken("CLOSE_PAREN", ")", state)],
    ["[", $ makeToken("OPEN_BRACKET", "[", state)],
    ["]", $ makeToken("CLOSE_BRACKET", "]", state)],
    ["{", $ makeToken("OPEN_BRACE", "{", state)],
    ["}", $ makeToken("CLOSE_BRACE", "}", state)],
    [",", $ makeToken("COMMA", ",", state)],
    [";", $ makeToken("SEMICOLON", ";", state)],
    [":", $ makeToken("COLON", ":", state)],
    ["=", $ (
      if(
        nextChar | eq(">"),
        then: $ makeToken("ARROW", "=>", state),
        else: $ makeToken("EQUALS", "=", state),
      )
    )],
    ["|", $ (
      if(
        nextChar | eq("."),
        then: $ makeToken("PIPE_DOT", "|.", state),
        else: $ makeToken("PIPE", "|", state),
      )
    )],
    ["@", $ makeToken("AT", "@", state)],
    [".", $ makeToken("DOT", ".", state)],
    ["$", $ makeToken("DOLLAR", "$", state)],
    ["*", $ (
      if(
        nextChar | eq("*"),
        then: $ makeToken("DOUBLE_STAR", "**", state),
        else: $ makeToken("STAR", "*", state),
      )
    )],
    ["_", $ makeToken("UNDERSCORE", "_", state)],
    ["/", $ makeToken("SLASH", "/", state)],
    else: $ errorAt("invalidCharacter", code, state, character: code @ state.index),
  );
  [token, newState]
);

makeToken = (type, text, state) => (
  endIndex = state.index | add(text | length);
  token = {
    type:,
    value: null,
    text:,
    line: state.line,
    column: state.index | sub(state.lineStart),
  };
  [token, {**state, index: endIndex}]
);

errorAt = (type, code, state, **properties) => (
  error(type, line: state.line, column: state.index | sub(state.lineStart), **properties)
);

error = (type, line:, column:, **properties) => (
  throw(newError(type, line:, column:, **properties))
);
