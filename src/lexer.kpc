lex = (code) => (
  lexTokens(code, 1, 1, 0)
);

lexTokens = (code, index, line, lineStart) => (
  if(
    index | ge(code | length),
    then: $ newStream(
      value: $ {
        type: "EOF",
        value: null,
        text: "",
        line: line,
        column: code | length | sub(lineStart) | add(1),
      },
      next: emptyStream,
    ),
    else: $ (
      [token, endIndex, newLine, newLineStart] = lexToken(code, index, line, lineStart);
      newIndex = endIndex | up;
      if(
        token | isNull,
        then: $ lexTokens(code, newIndex, newLine, newLineStart),
        else: $ newStream(
          value: $ token,
          next: $ lexTokens(code, newIndex, newLine, newLineStart),
        ),
      )
    ),
  )
);

lexToken = (code, index, line, lineStart) => (
  char = code @ index;
  if(
    char | eq("\""),
    then: $ lexString(code, index, line, lineStart),
    else: $ if(
      char | eq("`"),
      then: $ lexRawString(code, index, line, lineStart),
      else: $ if(
        char | eq("/") | and($ code @ (index | add(1)) | eq("/")),
        then: $ lexComment(code, index, line, lineStart),
        else: $ if(
          char | eq(" ") | or($ char | eq("\t")),
          then: $ lexWhitespace(code, index, line, lineStart),
          else: $ if(
            char | eq("\r") | and($ code @ (index | add(1)) | eq("\n")),
            then: $ [null, index | add(2), line | add(1), index | add(2)],
            else: $ if(
              char | eq("\n") | or($ char | eq("\r")),
              then: $ [null, index | add(1), line | add(1), index | add(1)],
              else: $ if(
                char | eq("-") | or($ char | ge("0") | and($ char | le("9"))),
                then: $ lexNumber(code, index, line, lineStart),
                else: $ if(
                  char | ge("A") | and($ char | le("Z")) | or($ char | ge("a") | and($ char | le("z"))),
                  then: $ lexName(code, index, line, lineStart),
                  else: $ lexOperator(code, index, line, lineStart),
                ),
              ),
            ),
          ),
        ),
      ),
    ),
  )
);

lexString = (code, index, line, lineStart) => (
  startIndex = index;
  quoteStart = index | add(1);
  [text, value, contentEnd] = lexStringContent(code, quoteStart, "\"", "", false);
  if(
    contentEnd | ge(code | length),
    then: $ throwError("unclosedString", line, contentEnd | sub(lineStart) | add(1)),
    else: $ (
      finalText = [text, code @ contentEnd] | join;
      finalIndex = contentEnd | add(1);
      token = {
        type: "LITERAL",
        value: value,
        text: finalText,
        line: line,
        column: startIndex | sub(lineStart) | add(1),
      };
      [token, finalIndex, line, lineStart]
    ),
  )
);

lexStringContent = (code, index, text, value, escaped) => (
  if(
    index | ge(code | length),
    then: $ [text, value, index],
    else: $ (
      char = code @ index;
      if(
        escaped,
        then: $ (
          if(
            char | eq("u") | and($ code @ (index | add(1)) | eq("{")),
            then: $ lexUnicodeEscape(code, index, text, value),
            else: $ (
              escapedChar = if(
                char | eq("n"),
                then: $ "\n",
                else: $ if(
                  char | eq("t"),
                  then: $ "\t",
                  else: $ if(
                    char | eq("r"),
                    then: $ "\r",
                    else: $ if(
                      char | eq("\\"),
                      then: $ "\\",
                      else: $ if(
                        char | eq("\""),
                        then: $ "\"",
                        else: $ char,
                      ),
                    ),
                  ),
                ),
              );
              newText = [text, "\\", char] | join;
              newValue = [value, escapedChar] | join;
              lexStringContent(code, index | add(1), newText, newValue, false)
            ),
          )
        ),
        else: $ if(
          char | eq("\\"),
          then: $ lexStringContent(code, index | add(1), text, value, true),
          else: $ if(
            char | eq("\""),
            then: $ [text, value, index],
            else: $ (
              newText = [text, char] | join;
              newValue = [value, char] | join;
              lexStringContent(code, index | add(1), newText, newValue, false)
            ),
          ),
        ),
      )
    ),
  )
);

lexUnicodeEscape = (code, index, text, value) => (
  textWithPrefix = [text, "\\u{"] | join;
  braceStart = index | add(2);
  [hex, hexEnd] = lexHexDigits(code, braceStart, "");
  if(
    code @ hexEnd | eq("}"),
    then: $ (
      finalText = [textWithPrefix, hex, "}"] | join;
      braceEnd = hexEnd | add(1);
      codePoint = parseHex(hex);
      char = codePointToString(codePoint);
      finalValue = [value, char] | join;
      [finalText, finalValue, braceEnd]
    ),
    else: $ throwError("invalidUnicodeEscape", 0, 0),
  )
);

lexHexDigits = (code, index, hex) => (
  if(
    index | ge(code | length),
    then: $ [hex, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")) | or($ char | ge("a") | and($ char | le("f")) | or($ char | ge("A") | and($ char | le("F")))),
        then: $ lexHexDigits(code, index | add(1), [hex, char] | join),
        else: $ [hex, index],
      )
    ),
  )
);

parseHex = (hex) => (
  parseHexDigits(hex, 0, 0)
);

parseHexDigits = (hex, index, value) => (
  if(
    index | ge(hex | length),
    then: $ value,
    else: $ (
      char = hex @ index;
      codePoints = char | toCodePoints;
      charCode = codePoints @ 0;
      digit = if(
        char | ge("0") | and($ char | le("9")),
        then: $ charCode | sub("0" | toCodePoints @ 0),
        else: $ if(
          char | ge("a") | and($ char | le("f")),
          then: $ charCode | sub("a" | toCodePoints @ 0) | add(10),
          else: $ charCode | sub("A" | toCodePoints @ 0) | add(10),
        ),
      );
      parseHexDigits(hex, index | add(1), value | mul(16) | add(digit))
    ),
  )
);

codePointToString = (codePoint) => (
  [codePoint] | fromCodePoints
);

lexRawString = (code, index, line, lineStart) => (
  startIndex = index;
  backtickStart = index | add(1);
  [text, contentEnd] = lexRawStringContent(code, backtickStart, "`");
  if(
    contentEnd | ge(code | length),
    then: $ throwError("unclosedRawString", line, contentEnd | sub(lineStart) | add(1)),
    else: $ (
      finalText = [text, "`"] | join;
      finalIndex = contentEnd | add(1);
      value = finalText | slice(1, finalText | length | sub(1));
      token = {
        type: "LITERAL",
        value: value,
        text: finalText,
        line: line,
        column: startIndex | sub(lineStart) | add(1),
      };
      [token, finalIndex, line, lineStart]
    ),
  )
);

lexRawStringContent = (code, index, text) => (
  if(
    index | ge(code | length),
    then: $ [text, index],
    else: $ if(
      code @ index | eq("`"),
      then: $ [text, index],
      else: $ lexRawStringContent(code, index | add(1), [text, code @ index] | join),
    ),
  )
);

lexComment = (code, index, line, lineStart) => (
  startIndex = index;
  commentStart = index | add(2);
  [commentEnd, newLine, newLineStart] = lexCommentContent(code, commentStart, line, lineStart);
  [null, commentEnd, newLine, newLineStart]
);

lexCommentContent = (code, index, line, lineStart) => (
  if(
    index | ge(code | length),
    then: $ [index, line, lineStart],
    else: $ (
      char = code @ index;
      if(
        char | eq("\r") | and($ code @ (index | add(1)) | eq("\n")),
        then: $ [index | add(2), line | add(1), index | add(2)],
        else: $ if(
          char | eq("\n") | or($ char | eq("\r")),
          then: $ [index | add(1), line | add(1), index | add(1)],
          else: $ lexCommentContent(code, index | add(1), line, lineStart),
        ),
      )
    ),
  )
);

lexWhitespace = (code, index, line, lineStart) => (
  [index] = lexWhitespaceContent(code, index);
  [null, index, line, lineStart]
);

lexWhitespaceContent = (code, index) => (
  if(
    index | ge(code | length),
    then: $ [index],
    else: $ if(
      code @ index | eq(" ") | or($ code @ index | eq("\t")),
      then: $ lexWhitespaceContent(code, index | add(1)),
      else: $ [index],
    ),
  )
);

lexNumber = (code, index, line, lineStart) => (
  startIndex = index;
  negative = code @ index | eq("-");
  [numberStart, initialText] = if(
    negative,
    then: $ [index | add(1), "-"],
    else: $ [index, ""],
  );
  [textAfterInt, intEnd] = lexInteger(code, numberStart, initialText);
  [textAfterDecimal, decimalEnd] = lexDecimalPart(code, intEnd, textAfterInt);
  [finalText, exponentEnd] = lexExponentPart(code, decimalEnd, textAfterDecimal);
  value = parseNumber(finalText);
  token = {
    type: "LITERAL",
    value: value,
    text: finalText,
    line: line,
    column: startIndex | sub(lineStart) | add(1),
  };
  [token, exponentEnd, line, lineStart]
);

lexInteger = (code, index, text) => (
  if(
    index | ge(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | eq("0"),
        then: $ [[text, "0"] | join, index | add(1)],
        else: $ if(
          char | ge("1") | and($ char | le("9")),
          then: $ lexIntegerDigits(code, index | add(1), [text, char] | join),
          else: $ [text, index],
        ),
      )
    ),
  )
);

lexIntegerDigits = (code, index, text) => (
  if(
    index | ge(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")),
        then: $ lexIntegerDigits(code, index | add(1), [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

lexDecimalPart = (code, index, text) => (
  if(
    index | ge(code | length),
    then: $ [text, index],
    else: $ if(
      code @ index | eq("."),
      then: $ (
        textWithDot = [text, "."] | join;
        dotEnd = index | add(1);
        lexDecimalDigits(code, dotEnd, textWithDot)
      ),
      else: $ [text, index],
    ),
  )
);

lexDecimalDigits = (code, index, text) => (
  if(
    index | ge(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")),
        then: $ lexDecimalDigits(code, index | add(1), [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

lexExponentPart = (code, index, text) => (
  if(
    index | ge(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | eq("e") | or($ char | eq("E")),
        then: $ (
          textWithE = [text, char] | join;
          eEnd = index | add(1);
          [textAfterSign, signEnd] = lexExponentSign(code, eEnd, textWithE);
          lexExponentDigits(code, signEnd, textAfterSign)
        ),
        else: $ [text, index],
      )
    ),
  )
);

lexExponentSign = (code, index, text) => (
  if(
    index | ge(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | eq("+") | or($ char | eq("-")),
        then: $ [[text, char] | join, index | add(1)],
        else: $ [text, index],
      )
    ),
  )
);

lexExponentDigits = (code, index, text) => (
  if(
    index | ge(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")),
        then: $ lexExponentDigits(code, index | add(1), [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

parseNumber = (text) => (
  text | toNumber
);

lexName = (code, index, line, lineStart) => (
  startIndex = index;
  [text, nameEnd] = lexNameContent(code, index, "");
  [kind, value] = if(
    text | eq("null"),
    then: $ ["LITERAL", null],
    else: $ if(
      text | eq("false"),
      then: $ ["LITERAL", false],
      else: $ if(
        text | eq("true"),
        then: $ ["LITERAL", true],
        else: $ ["NAME", null],
      ),
    ),
  );
  token = {
    type: kind,
    value: value,
    text: text,
    line: line,
    column: startIndex | sub(lineStart),
  };
  [token, nameEnd, line, lineStart]
);

lexNameContent = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("A") | and($ char | le("Z")) | or($ char | ge("a") | and($ char | le("z")) | or($ char | ge("0") | and($ char | le("9")))),
        then: $ lexNameContent(code, index | add(1), [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

lexOperator = (code, index, line, lineStart) => (
  startIndex = index;
  char = code @ index;
  if(
    char | eq("("),
    then: $ makeToken("OPEN_PAREN", "(", index | add(1), line, lineStart),
    else: $ if(
      char | eq(")"),
      then: $ makeToken("CLOSE_PAREN", ")", index | add(1), line, lineStart),
      else: $ if(
        char | eq("["),
        then: $ makeToken("OPEN_BRACKET", "[", index | add(1), line, lineStart),
        else: $ if(
          char | eq("]"),
          then: $ makeToken("CLOSE_BRACKET", "]", index | add(1), line, lineStart),
          else: $ if(
            char | eq("{"),
            then: $ makeToken("OPEN_BRACE", "{", index | add(1), line, lineStart),
            else: $ if(
              char | eq("}"),
              then: $ makeToken("CLOSE_BRACE", "}", index | add(1), line, lineStart),
              else: $ if(
                char | eq(","),
                then: $ makeToken("COMMA", ",", index | add(1), line, lineStart),
                else: $ if(
                  char | eq(";"),
                  then: $ makeToken("SEMICOLON", ";", index | add(1), line, lineStart),
                  else: $ if(
                    char | eq(":"),
                    then: $ makeToken("COLON", ":", index | add(1), line, lineStart),
                    else: $ if(
                      char | eq("=") | and($ code @ (index | add(1)) | eq(">")),
                      then: $ makeToken("ARROW", "=>", index | add(2), line, lineStart),
                      else: $ if(
                        char | eq("="),
                        then: $ makeToken("EQUALS", "=", index | add(1), line, lineStart),
                        else: $ if(
                          char | eq("|") | and($ code @ (index | add(1)) | eq(".")),
                          then: $ makeToken("PIPE_DOT", "|.", index | add(2), line, lineStart),
                          else: $ if(
                            char | eq("|"),
                            then: $ makeToken("PIPE", "|", index | add(1), line, lineStart),
                            else: $ if(
                              char | eq("@"),
                              then: $ makeToken("AT", "@", index | add(1), line, lineStart),
                              else: $ if(
                                char | eq("."),
                                then: $ makeToken("DOT", ".", index | add(1), line, lineStart),
                                else: $ if(
                                  char | eq("$"),
                                  then: $ makeToken("DOLLAR", "$", index | add(1), line, lineStart),
                                  else: $ if(
                                    char | eq("*") | and($ code @ (index | add(1)) | eq("*")),
                                    then: $ makeToken("DOUBLE_STAR", "**", index | add(2), line, lineStart),
                                    else: $ if(
                                      char | eq("*"),
                                      then: $ makeToken("STAR", "*", index | add(1), line, lineStart),
                                      else: $ if(
                                        char | eq("_"),
                                        then: $ makeToken("UNDERSCORE", "_", index | add(1), line, lineStart),
                                        else: $ if(
                                          char | eq("/"),
                                          then: $ makeToken("SLASH", "/", index | add(1), line, lineStart),
                                          else: $ throwError("invalidCharacter", line, startIndex | sub(lineStart) | add(1), char),
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    ),
  )
);

makeToken = (type, text, newIndex, line, lineStart) => (
  startIndex = newIndex | sub(text | length);
  token = {
    type: type,
    value: null,
    text: text,
    line: line,
    column: startIndex | sub(lineStart) | add(1),
  };
  [token, newIndex, line, lineStart]
);

throwError = (errorName, line, column, char: = null) => (
  // Error throwing will be handled by the parser
  null
);

parseStringValue = (text) => (
  // We build the value during lexing, so just return the accumulated value
  // This function is not actually used - value is built in lexStringContent
  ""
);
