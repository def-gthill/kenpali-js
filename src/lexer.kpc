lex = (code) => (
  lexTokens(code, 1, 1, 0)
);

lexTokens = (code, index, line, lineStart) => (
  if(
    index | gt(code | length),
    then: $ newStream(
      value: $ {
        type: "EOF",
        value: null,
        text: "",
        line: line,
        column: code | length | sub(lineStart) | up,
      },
      next: emptyStream,
    ),
    else: $ (
      [token, endIndex, newLine, newLineStart] = lexToken(code, index, line, lineStart);
      if(
        token | isNull,
        then: $ lexTokens(code, endIndex, newLine, newLineStart),
        else: $ newStream(
          value: $ token,
          next: $ lexTokens(code, endIndex, newLine, newLineStart),
        ),
      )
    ),
  )
);

lexToken = (code, index, line, lineStart) => (
  char = code @ index;
  nextChar = code | at(index | add(1), default: $ null);
  char | switch(
    ["\"", $ lexString(code, index, line, lineStart)],
    ["`", $ lexRawString(code, index, line, lineStart)],
    [| eq("/") | and($ nextChar | eq("/")), $ lexComment(code, index, line, lineStart)],
    [| eqOneOf(" ", "\t"), $ lexWhitespace(code, index, line, lineStart)],
    [| eq("\r") | and($ nextChar | eq("\n")), $ [null, index | add(2), line | add(1), index | add(2)]],
    ["\n", $ [null, index | add(1), line | add(1), index | add(1)]],
    ["\r", $ [null, index | add(1), line | add(1), index | add(1)]],
    ["-", $ lexNumber(code, index, line, lineStart)],
    [| isBetween("0", "9"), $ lexNumber(code, index, line, lineStart)],
    [| isBetween("A", "Z"), $ lexName(code, index, line, lineStart)],
    [| isBetween("a", "z"), $ lexName(code, index, line, lineStart)],
    else: $ lexOperator(code, index, line, lineStart),
  )
);

lexString = (code, index, line, lineStart) => (
  startIndex = index;
  quoteStart = index | add(1);
  [text, contentEnd] = gatherStringContent(code, quoteStart, line, lineStart);
  value = getStringValue(text, 1, line, lineStart, "", false);
  if(
    contentEnd | ge(code | length),
    then: $ error("unclosedStringLiteral", line:, column: contentEnd | sub(lineStart), value: ["\"", value] | join),
    else: $ (
      finalText = ["\"", text, "\""] | join;
      finalIndex = contentEnd | add(2);
      token = {
        type: "LITERAL",
        value: value,
        text: finalText,
        line: line,
        column: startIndex | sub(lineStart),
      };
      [token, finalIndex, line, lineStart]
    ),
  )
);

gatherStringContent = (code, index, line, lineStart) => (
  endIndex = index
  | build(up)
  | withPreviousRunning(
    start: false,
    next: (index, state: isEscaped) => (
      isEscaped | not | and($ code @ index | eq("\\"))
    )
  )
  | while(([isEscaped, index]) => (
    index | le(code | length) | and(
      $ isEscaped | or(
        $ code @ index | eq("\"") | not
      )
    )
  ))
  | last @ 2;
  [code | slice(from: index, to: endIndex), endIndex]
);

getStringValue = (code, index, line, lineStart, value, escaped) => (
  if(
    index | gt(code | length),
    then: $ value,
    else: $ (
      char = code @ index;
      if(
        escaped,
        then: $ (
          if(
            char | eq("u") | and($ code @ (index | add(1)) | eq("{")),
            then: $ lexUnicodeEscape(code, index, value),
            else: $ (
              escapedChar = char | switch(
                ["\"", $ "\""],
                ["\\", $ "\\"],
                ["\/", $ "\/"],
                ["b", $ "\b"],
                ["f", $ "\f"],
                ["n", $ "\n"],
                ["r", $ "\r"],
                ["t", $ "\t"],
                else: $ error("invalidStringLiteral", line:, column: index | sub(lineStart), value: ["\"", code, "\""] | join),
              );
              newValue = [value, escapedChar] | join;
              getStringValue(code, index | add(1), line, lineStart, newValue, false)
            ),
          )
        ),
        else: $ (
          char | switch(
            ["\\", $ getStringValue(code, index | add(1), line, lineStart, value, true)],
            ["\"", $ value],
            else: $ (
              newValue = [value, char] | join;
              getStringValue(code, index | add(1), line, lineStart, newValue, false)
            ),
          )
        ),
      )
    ),
  )
);

lexUnicodeEscape = (code, index, value) => (
  braceStart = index | add(2);
  [hex, hexEnd] = lexHexDigits(code, braceStart, "");
  if(
    code | at(hexEnd, default: $ null) | eq("}"),
    then: $ (
      braceEnd = hexEnd | add(1);
      codePoint = parseHex(hex);
      char = codePointToString(codePoint);
      finalValue = [value, char] | join;
      finalValue
    ),
    else: $ error("invalidStringLiteral", line: 0, column: 0, value: ["\"", code, "\""] | join),
  )
);

lexHexDigits = (code, index, hex) => (
  if(
    index | gt(code | length),
    then: $ [hex, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")) | or($ char | ge("a") | and($ char | le("f")) | or($ char | ge("A") | and($ char | le("F")))),
        then: $ lexHexDigits(code, index | add(1), [hex, char] | join),
        else: $ [hex, index],
      )
    ),
  )
);

parseHex = (hex) => (
  parseHexDigits(hex, 1, 0)
);

parseHexDigits = (hex, index, value) => (
  if(
    index | gt(hex | length),
    then: $ value,
    else: $ (
      char = hex @ index;
      charCode = char | toCodePoints | first;
      digit = char | switch(
        [| isBetween("0", "9"), $ charCode | sub("0" | toCodePoints | first)],
        [| isBetween("a", "f"), $ charCode | sub("a" | toCodePoints | first) | add(10)],
        [| isBetween("A", "F"), $ charCode | sub("A" | toCodePoints | first) | add(10)],
        else: $ 0,
      );
      parseHexDigits(hex, index | add(1), value | mul(16) | add(digit))
    ),
  )
);

codePointToString = (codePoint) => (
  [codePoint] | fromCodePoints
);

lexRawString = (code, index, line, lineStart) => (
  startIndex = index;
  backtickStart = index | add(1);
  [text, contentEnd] = lexRawStringContent(code, backtickStart, "`");
  if(
    contentEnd | gt(code | length),
    then: $ error("unclosedStringLiteral", line:, column: contentEnd | sub(lineStart), value: text),
    else: $ (
      finalText = [text, "`"] | join;
      finalIndex = contentEnd | add(1);
      value = finalText | slice(from: 2, to: -2);
      token = {
        type: "LITERAL",
        value: value,
        text: finalText,
        line: line,
        column: startIndex | sub(lineStart),
      };
      [token, finalIndex, line, lineStart]
    ),
  )
);

lexRawStringContent = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ if(
      code @ index | eq("`"),
      then: $ [text, index],
      else: $ lexRawStringContent(code, index | add(1), [text, code @ index] | join),
    ),
  )
);

lexComment = (code, index, line, lineStart) => (
  startIndex = index;
  commentStart = index | add(2);
  [commentEnd, newLine, newLineStart] = lexCommentContent(code, commentStart, line, lineStart);
  [null, commentEnd, newLine, newLineStart]
);

lexCommentContent = (code, index, line, lineStart) => (
  if(
    index | gt(code | length),
    then: $ [index, line, lineStart],
    else: $ (
      char = code @ index;
      if(
        char | eq("\r") | and($ code @ (index | add(1)) | eq("\n")),
        then: $ [index | add(2), line | add(1), index | add(2)],
        else: $ if(
          char | eq("\n") | or($ char | eq("\r")),
          then: $ [index | add(1), line | add(1), index | add(1)],
          else: $ lexCommentContent(code, index | add(1), line, lineStart),
        ),
      )
    ),
  )
);

lexWhitespace = (code, index, line, lineStart) => (
  [endIndex] = lexWhitespaceContent(code, index);
  [null, endIndex, line, lineStart]
);

lexWhitespaceContent = (code, index) => (
  if(
    index | gt(code | length),
    then: $ [index],
    else: $ if(
      code @ index | eq(" ") | or($ code @ index | eq("\t")),
      then: $ lexWhitespaceContent(code, index | add(1)),
      else: $ [index],
    ),
  )
);

lexNumber = (code, index, line, lineStart) => (
  startIndex = index;
  negative = code @ index | eq("-");
  [numberStart, initialText] = if(
    negative,
    then: $ [index | add(1), "-"],
    else: $ [index, ""],
  );
  [textAfterInt, intEnd] = lexInteger(code, numberStart, initialText);
  [textAfterDecimal, decimalEnd] = lexDecimalPart(code, intEnd, textAfterInt);
  [finalText, exponentEnd] = lexExponentPart(code, decimalEnd, textAfterDecimal);
  value = parseNumber(finalText);
  token = {
    type: "LITERAL",
    value: value,
    text: finalText,
    line: line,
    column: startIndex | sub(lineStart),
  };
  [token, exponentEnd, line, lineStart]
);

lexInteger = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | eq("0"),
        then: $ [[text, "0"] | join, index | add(1)],
        else: $ if(
          char | ge("1") | and($ char | le("9")),
          then: $ lexIntegerDigits(code, index | add(1), [text, char] | join),
          else: $ [text, index],
        ),
      )
    ),
  )
);

lexIntegerDigits = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")),
        then: $ lexIntegerDigits(code, index | add(1), [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

lexDecimalPart = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ if(
      code @ index | eq("."),
      then: $ (
        textWithDot = [text, "."] | join;
        dotEnd = index | add(1);
        lexDecimalDigits(code, dotEnd, textWithDot)
      ),
      else: $ [text, index],
    ),
  )
);

lexDecimalDigits = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")),
        then: $ lexDecimalDigits(code, index | add(1), [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

lexExponentPart = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | eq("e") | or($ char | eq("E")),
        then: $ (
          textWithE = [text, char] | join;
          eEnd = index | add(1);
          [textAfterSign, signEnd] = lexExponentSign(code, eEnd, textWithE);
          lexExponentDigits(code, signEnd, textAfterSign)
        ),
        else: $ [text, index],
      )
    ),
  )
);

lexExponentSign = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | eq("+") | or($ char | eq("-")),
        then: $ [[text, char] | join, index | add(1)],
        else: $ [text, index],
      )
    ),
  )
);

lexExponentDigits = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("0") | and($ char | le("9")),
        then: $ lexExponentDigits(code, index | add(1), [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

parseNumber = (text) => (
  text | toNumber
);

lexName = (code, index, line, lineStart) => (
  startIndex = index;
  [text, nameEnd] = lexNameContent(code, index, "");
  [kind, value] = text | switch(
    ["null", $ ["LITERAL", null]],
    ["false", $ ["LITERAL", false]],
    ["true", $ ["LITERAL", true]],
    else: $ ["NAME", null],
  );
  token = {
    type: kind,
    value: value,
    text: text,
    line: line,
    column: startIndex | sub(lineStart),
  };
  [token, nameEnd, line, lineStart]
);

lexNameContent = (code, index, text) => (
  if(
    index | gt(code | length),
    then: $ [text, index],
    else: $ (
      char = code @ index;
      if(
        char | ge("A") | and($ char | le("Z")) | or($ char | ge("a") | and($ char | le("z")) | or($ char | ge("0") | and($ char | le("9")))),
        then: $ lexNameContent(code, index | add(1), [text, char] | join),
        else: $ [text, index],
      )
    ),
  )
);

lexOperator = (code, index, line, lineStart) => (
  startIndex = index;
  char = code @ index;
  nextChar = code | at(index | add(1), default: $ null);
  char | switch(
    ["(", $ makeToken("OPEN_PAREN", "(", index | add(1), line, lineStart)],
    [")", $ makeToken("CLOSE_PAREN", ")", index | add(1), line, lineStart)],
    ["[", $ makeToken("OPEN_BRACKET", "[", index | add(1), line, lineStart)],
    ["]", $ makeToken("CLOSE_BRACKET", "]", index | add(1), line, lineStart)],
    ["{", $ makeToken("OPEN_BRACE", "{", index | add(1), line, lineStart)],
    ["}", $ makeToken("CLOSE_BRACE", "}", index | add(1), line, lineStart)],
    [",", $ makeToken("COMMA", ",", index | add(1), line, lineStart)],
    [";", $ makeToken("SEMICOLON", ";", index | add(1), line, lineStart)],
    [":", $ makeToken("COLON", ":", index | add(1), line, lineStart)],
    ["=", $ (
      if(
        nextChar | eq(">"),
        then: $ makeToken("ARROW", "=>", index | add(2), line, lineStart),
        else: $ makeToken("EQUALS", "=", index | add(1), line, lineStart),
      )
    )],
    ["|", $ (
      if(
        nextChar | eq("."),
        then: $ makeToken("PIPE_DOT", "|.", index | add(2), line, lineStart),
        else: $ makeToken("PIPE", "|", index | add(1), line, lineStart),
      )
    )],
    ["@", $ makeToken("AT", "@", index | add(1), line, lineStart)],
    [".", $ makeToken("DOT", ".", index | add(1), line, lineStart)],
    ["$", $ makeToken("DOLLAR", "$", index | add(1), line, lineStart)],
    ["*", $ (
      if(
        nextChar | eq("*"),
        then: $ makeToken("DOUBLE_STAR", "**", index | add(2), line, lineStart),
        else: $ makeToken("STAR", "*", index | add(1), line, lineStart),
      )
    )],
    ["_", $ makeToken("UNDERSCORE", "_", index | add(1), line, lineStart)],
    ["/", $ makeToken("SLASH", "/", index | add(1), line, lineStart)],
    else: $ error("invalidCharacter", line:, column: startIndex | sub(lineStart), character: char),
  )
);

makeToken = (type, text, newIndex, line, lineStart) => (
  startIndex = newIndex | sub(text | length);
  token = {
    type: type,
    value: null,
    text: text,
    line: line,
    column: startIndex | sub(lineStart),
  };
  [token, newIndex, line, lineStart]
);

error = (type, line:, column:, **properties) => (
  throw(newError(type, line:, column:, **properties))
);
