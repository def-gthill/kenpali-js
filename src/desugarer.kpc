desugar = (ast) => (
  ast
  | splitMixedLists
  | normalizeExpressionStatements
  | removeSpecializedSpreads
  | removeSpecializedRests
  | convertFunctionSyntax
  | makePipeArgs
  | convertPipelines
  | normalizeObjectSyntax
  | removeGroups
  | removeEmptyLists
);

splitMixedLists = (ast) => (
  transformTree(ast, splitMixedListsTransform)
);

splitMixedListsTransform = (node) => (
  if(
    node.type | eq("arrow"),
    then: $ (
      params = node.params;
      if(
        params.type | eq("mixedParamList"),
        then: $ (
          [posParams, namedParams] = splitParamList(params.params);
          {type: node.type, params: {type: "paramList", posParams: posParams, namedParams: namedParams}, body: node.body}
        ),
        else: $ node,
      )
    ),
    else: $ if(
      node.type | eq("args"),
      then: $ (
        args = node.args;
        if(
          args.type | eq("mixedArgList"),
          then: $ (
            [posArgs, namedArgs] = splitArgList(args.args);
            {type: node.type, args: {type: "argList", posArgs: posArgs, namedArgs: namedArgs}}
          ),
          else: $ node,
        )
      ),
      else: $ if(
        node.type | eq("pipeArgs"),
        then: $ (
          args = node.args;
          if(
            args.type | eq("mixedArgList"),
            then: $ (
              [posArgs, namedArgs] = splitArgList(args.args);
              {type: node.type, callee: node.callee, args: {type: "argList", posArgs: posArgs, namedArgs: namedArgs}}
            ),
            else: $ node,
          )
        ),
        else: $ node,
      ),
    ),
  )
);

splitParamList = (params) => (
  isNamed = (param) => (
    param.type | eq("optional") | and($ param.name | isNamed) | or(
      $ param.type | eqOneOf("objectRest", "keyName", "entry"),
    )
  );
  {yes: namedParams, no: posParams} = params | sift(isNamed);
  [posParams, namedParams]
);

splitArgList = (args) => (
  isNamed = (arg) => (
    arg.type | eqOneOf("objectSpread", "keyName", "entry")
  );
  {yes: namedArgs, no: posArgs} = args | sift(isNamed);
  [posArgs, namedArgs]
);

normalizeExpressionStatements = (ast) => (
  transformTree(ast, normalizeExpressionStatementsTransform)
);

normalizeExpressionStatementsTransform = (node) => (
  if(
    node.type | eq("block"),
    then: $ (
      defs = node.defs | transformArray((def) => (
        [name, value] = def;
        if(
          name | isNull,
          then: $ [{type: "ignore"}, value],
          else: $ def,
        )
      ));
      {type: node.type, defs: defs, result: node.result}
    ),
    else: $ node,
  )
);

removeSpecializedSpreads = (ast) => (
  transformTree(ast, removeSpecializedSpreadsTransform)
);

removeSpecializedSpreadsTransform = (node) => (
  if(
    node.type | eq("arraySpread"),
    then: $ {type: "spread", value: node.value},
    else: $ if(
      node.type | eq("objectSpread"),
      then: $ {type: "spread", value: node.value},
      else: $ node,
    ),
  )
);

removeSpecializedRests = (ast) => (
  transformTree(ast, removeSpecializedRestsTransform)
);

removeSpecializedRestsTransform = (node) => (
  if(
    node.type | eq("arrayRest"),
    then: $ {type: "rest", name: node.name},
    else: $ if(
      node.type | eq("objectRest"),
      then: $ {type: "rest", name: node.name},
      else: $ node,
    ),
  )
);

convertFunctionSyntax = (ast) => (
  transformTree(ast, convertFunctionSyntaxTransform)
);

convertFunctionSyntaxTransform = (node) => (
  if(
    node.type | eq("arrow"),
    then: $ (
      params = node.params;
      [posParams, namedParams] = if(
        params.type | eq("paramList"),
        then: $ [params.posParams, params.namedParams],
        else: $ [[], []],
      );
      {type: "function", body: node.body, posParams: posParams, namedParams: namedParams}
    ),
    else: $ if(
      node.type | eq("constantFunction"),
      then: $ ast/function(posParams: [], namedParams: [], node.body),
      else: $ node,
    ),
  )
);

makePipeArgs = (ast) => (
  transformTree(ast, makePipeArgsTransform)
);

makePipeArgsTransform = (node) => (
  if(
    node.type | eq("pipe"),
    then: $ (
      callee = node.callee;
      if(
        callee.type | eq("pipelineCall") | and($ callee.pipeline.type | eq("tightPipeline")),
        then: $ (
          steps = callee.pipeline.steps;
          if(
            steps | isEmpty | not | and($ steps | last |.type | eq("args")),
            then: $ (
              [lastStep, *otherSteps] = steps;
              if(
                otherSteps | isEmpty,
                then: $ {type: "pipeArgs", callee: callee.start, args: lastStep.args},
                else: $ (
                  otherPipeline = {type: "tightPipeline", steps: otherSteps};
                  {type: "pipeArgs", callee: {type: "pipelineCall", start: callee.start, pipeline: otherPipeline}, args: lastStep.args}
                ),
              )
            ),
            else: $ node,
          )
        ),
        else: $ node,
      )
    ),
    else: $ node,
  )
);

convertPipelines = (ast) => (
  transformTree(ast, convertPipelinesTransform)
);

convertPipelinesTransform = (node) => (
  node.type | switch(
    ["pipelineCall", $ (
      start = node.start;
      pipeline = node.pipeline;
      if(
        pipeline.type | eq("loosePipeline"),
        then: $ convertLoosePipeline(start, pipeline.steps),
        else: $ convertTightPipeline(start, pipeline.steps),
      )
    )],
    ["loosePipeline", $ (
      arg = ast/name("pipelineArg");
      ast/function(
        posParams: [arg],
        namedParams: [],
        convertLoosePipeline(arg, node.steps),
      )
    )],
    else: $ node,
  )
);

convertLoosePipeline = (start, steps) => (
  convertLoosePipelineSteps(start, steps, 1)
);

convertLoosePipelineSteps = (axis, steps, index) => (
  if(
    index | gt(steps | length),
    then: $ axis,
    else: $ (
      step = steps @ index;
      newAxis = if(
        step.type | eq("pipeArgs"),
        then: $ (
          posArgs = if(
            step.args.type | eq("argList"),
            then: $ step.args.posArgs,
            else: $ [],
          );
          namedArgs = if(
            step.args.type | eq("argList"),
            then: $ step.args.namedArgs,
            else: $ [],
          );
          {type: "call", callee: step.callee, posArgs: [axis, *posArgs], namedArgs:}
        ),
        else: $ if(
          step.type | eq("pipeDot"),
          then: $ (
            tightSteps = [ast/dot(step.index), *step.steps];
            convertTightPipeline(axis, tightSteps)
          ),
          else: $ if(
            step.type | eq("pipe"),
            then: $ {type: "call", callee: step.callee, posArgs: [axis], namedArgs: []},
            else: $ if(
              step.type | eq("at"),
              then: $ {type: "index", collection: axis, index: step.index},
              else: $ axis,
            ),
          ),
        ),
      );
      convertLoosePipelineSteps(newAxis, steps, index | add(1))
    ),
  )
);

convertTightPipeline = (start, steps) => (
  convertTightPipelineSteps(start, steps, 1)
);

convertTightPipelineSteps = (axis, steps, index) => (
  if(
    index | gt(steps | length),
    then: $ axis,
    else: $ (
      step = steps @ index;
      newAxis = if(
        step.type | eq("args"),
        then: $ (
          posArgs = if(
            step.args.type | eq("argList"),
            then: $ step.args.posArgs,
            else: $ [],
          );
          namedArgs = if(
            step.args.type | eq("argList"),
            then: $ step.args.namedArgs,
            else: $ [],
          );
          {type: "call", callee: axis, posArgs:, namedArgs:}
        ),
        else: $ if(
          step.type | eq("dot"),
          then: $ (
            index = step.index | butIf(
              |.type | eq("name"),
              |.name | ast/literal,
            );
            ast/index(axis, index)
          ),
          else: $ axis,
        ),
      );
      convertTightPipelineSteps(newAxis, steps, index | add(1))
    ),
  )
);

normalizeObjectSyntax = (ast) => (
  transformTree(ast, normalizeObjectSyntaxTransform)
);

normalizeObjectSyntaxTransform = (node) => (
  node.type | switch(
    ["object", $ (
      entries = node.entries | transformArray(normalizeObjectElement);
      {**node, entries:}
    )],
    ["call", $ (
      namedArgs = node.namedArgs | transformArray(normalizeObjectElement);
      {**node, namedArgs:}
    )],
    ["objectPattern", $ (
      entries = node.entries | transformArray(normalizeObjectPatternElement);
      {**node, entries:}
    )],
    ["function", $ (
      namedParams = node.namedParams | transformArray(normalizeObjectPatternElement);
      {**node, namedParams:}
    )],
    else: $ node,
  )
);

normalizeObjectElement = (entry) => (
  if(
    entry.type | eq("keyName"),
    then: $ [
      if(
        entry.key.type | eq("name"),
        then: $ {type: "literal", value: entry.key.name},
        else: $ entry.key,
      ),
      entry.key,
    ],
    else: $ if(
      entry.type | eq("entry"),
      then: $ [
        if(
          entry.key.type | eq("name"),
          then: $ {type: "literal", value: entry.key.name},
          else: $ entry.key,
        ),
        entry.value,
      ],
      else: $ if(
        entry.type | eq("spread"),
        then: $ [{type: "spread"}, entry.value],
        else: $ entry,
      ),
    ),
  )
);

normalizeObjectPatternElement = (entry) => (
  entry.type | switch(
    ["optional", $ (
      [key, pattern] = normalizeObjectPatternElement(entry.name);
      [key, ast/optional(pattern, entry.defaultValue)]
    )],
    ["keyName", $ [
      if(
        entry.key.type | eq("name"),
        then: $ {type: "literal", value: entry.key.name},
        else: $ entry.key,
      ),
      entry.key,
    ]],
    ["entry", $ [
      if(
        entry.key.type | eq("name"),
        then: $ {type: "literal", value: entry.key.name},
        else: $ entry.key,
      ),
      entry.value,
    ]],
    ["rest", $ [ast/restKey(), entry.name]],
    else: $ entry,
  )
);

removeGroups = (ast) => (
  transformTree(ast, removeGroupsTransform)
);

removeGroupsTransform = (node) => (
  if(
    node.type | eq("group"),
    then: $ node.expression,
    else: $ node,
  )
);

removeEmptyLists = (ast) => (
  transformTree(ast, (node) => (
    node.type | switch(
      ["function", $ node | removeEmptyArrayProperties],
      ["call", $ node | removeEmptyArrayProperties],
      else: $ node,
    )
  ))
);

removeEmptyArrayProperties = (obj) => (
  obj
  | properties
  | where(([_, value]) => value | eq([]) | not)
  | toObject
);

transformTree = (node, f) => (
  classOf(node) | switch(
    [Array, $ node | transformArray(| transformTree(f))],
    [Object, $ (
      transformed = f(node);
      transformed
      | properties
      | transform(([key, value]) => [key, transformTree(value, f)])
      | toObject
    )],
    else: $ node,
  )
);

transformTreeOLD = (node, f) => (
  transformed = f(node);
  transformed.type | switch(
    ["array", $ (
      elements = transformed.elements | transformArray(| transformTree(f));
      {**transformed, elements:}
    )],
    ["arrayPattern", $ (
      names = transformed.names | transformArray(| transformTree(f));
      {**transformed, names:}
    )],
    ["object", $ (
      entries = transformed.entries | transformArray((entry) => (
        if(
          entry | isArray,
          then: $ entry | transformArray(| transformTree(f)),
          else: $ transformTree(entry, f),
        )
      ));
      {type: transformed.type, entries: entries}
    )],
    ["block", $ (
      defs = transformed.defs | transformArray((def) => (
        [name, value] = def;
        [
          if(
            name | isNull,
            then: $ null,
            else: $ transformTree(name, f),
          ),
          transformTree(value, f),
        ]
      ));
      result = transformTree(transformed.result, f);
      {type: transformed.type, defs: defs, result: result}
    )],
    ["function", $ (
      posParams = transformed.posParams | transform((param) => transformTree(param, f));
      namedParams = transformed.namedParams | transform((param) => (
        if(
          param | isArray,
          then: $ [
            transformTree(param @ 0, f),
            transformTree(param @ 1, f),
          ],
          else: $ transformTree(param, f),
        )
      ));
      body = transformTree(transformed.body, f);
      {type: transformed.type, posParams: posParams, namedParams: namedParams, body: body}
    )],
    ["call", $ (
      callee = transformTree(transformed.callee, f);
      posArgs = transformed.posArgs | transform((arg) => transformTree(arg, f));
      namedArgs = transformed.namedArgs | transform((arg) => (
        if(
          arg | isArray,
          then: $ [
            transformTree(arg @ 0, f),
            transformTree(arg @ 1, f),
          ],
          else: $ transformTree(arg, f),
        )
      ));
      {type: transformed.type, callee: callee, posArgs: posArgs, namedArgs: namedArgs}
    )],
    ["index", $ (
      collection = transformTree(transformed.collection, f);
      index = transformTree(transformed.index, f);
      {type: transformed.type, collection: collection, index: index}
    )],
    ["pipelineCall", $ (
      start = transformTree(transformed.start, f);
      pipeline = transformTree(transformed.pipeline, f);
      {**transformed, start:, pipeline:}
    )],
    else: $ transformed,
  )
);
