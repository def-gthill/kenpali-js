parse = (code, trace: = false) => (
  tracer = getTracer(trace);
  tokens = lexer/lex(code);
  [ast, tail] = tracer.inBlock("parse", $ parseExpression(tokens, tracer:));
  if(
    tail | firstType | eq("EOF"),
    then: $ ast | validateExpression | desugarer/desugar,
    else: $ errorAtToken("unparsedInput", tail.value()),
  )
);

getTracer = (trace) => if(trace, then: newTracer, else: dummyTracer);

newTracer = $ (
  indent = newVar(0);
  self = {
    inBlock: (name, f) => (
      self.log($ ["Begin ", name] | join);
      indent.get() | up | indent.set;
      result = f();
      indent.get() | down | indent.set;
      self.log($ ["End ", name] | join);
      result
    ),
    log: (valueF) => (
      [
        *("| " | repeat | keepFirst(indent.get())),
        valueF(),
      ]
      | join
      | write
    )
  };
  self
);

dummyTracer = $ {
  inBlock: (_, f) => f(),
  log: $ null,
};

parseExpression = (tokens, tracer:) => (
  parseBlock(tokens, tracer:)
);

parseBlock = (tokens, tracer:) => tracer.inBlock(
  "block",
  $ (
    [statements, tails] = parseStatement(tokens, tracer:)
    | build(([_, tokens]) => (
      parseStatement(tokens.next(), tracer:)
    ))
    | continueIf(([_, tokens]) => (
      tokens | firstType | eq("SEMICOLON")
    ))
    | unzip;
    result = if(
      statements | length | gt(1),
      then: $ statements | statementsToBlock,
      else: $ statements | first,
    );
    [result, tails | last]
  )
);

statementsToBlock = (statements) => (
  [*defs, result] = statements;
  blockDefs = defs
  | transform(statementToDef);
  ast/block(*blockDefs, result)
);

statementToDef = (statement) => (
  if(
    statement.type | eq("optional"),
    then: $ [statement.name, statement.defaultValue],
    else: $ [null, statement],
  )
);

parseStatement = (tokens, tracer:) => tracer.inBlock(
  "statement",
  $ (
    [entry, entryTail] = parseEntry(tokens, tracer:);
    if(
      entryTail | firstType | eq("EQUALS"),
      then: $ (
        [rhs, rhsTail] = parseAssignable(entryTail.next(), tracer:);
        [ast/optional(entry | expressionToNamePattern, rhs), rhsTail]
      ),
      else: $ [entry, entryTail],
    )
  )
);

expressionToNamePattern = (expression) => (
  expression.type | switch(
    ["array", $ expression | arrayToArrayPattern],
    ["object", $ expression | objectToObjectPattern],
    ["arraySpread", $ expression | arraySpreadToArrayRest],
    ["objectSpread", $ expression | objectSpreadToObjectRest],
    else: $ expression,
  )
);

arrayToArrayPattern = (array) => (
  ast/arrayPattern(*(array.elements | transform(expressionToNamePattern)))
);

objectToObjectPattern = (object) => (
  ast/objectPattern(*(object.entries))
);

arraySpreadToArrayRest = (arraySpread) => (
  ast/arrayRest(arraySpread.value)
);

objectSpreadToObjectRest = (objectSpread) => (
  ast/objectRest(objectSpread.value)
);

parseEntry = (tokens, tracer:) => tracer.inBlock(
  "entry",
  $ (
    [key, keyTail] = parseAssignable(tokens, tracer:);
    if(
      keyTail | firstType | eq("COLON"),
      then: $ (
        colonTail = keyTail.next();
        if(
          colonTail
          | firstType
          | eqOneOf("COMMA", "EQUALS", "CLOSE_PAREN", "CLOSE_BRACKET", "CLOSE_BRACE"),
          then: $ [ast/keyName(key), colonTail],
          else: $ (
            [value, valueTail] = parseAssignable(colonTail, tracer:);
            [ast/entry(key, value), valueTail]
          )
        )
      ),
      else: $ [key, keyTail],
    )
  )
);

parseAssignable = (tokens, tracer:) => (
  tokens | firstType | switch(
    ["DOLLAR", $ parseConstantFunction(tokens, tracer:)],
    [| eqOneOf("PIPE_DOT", "PIPE", "AT"), $ parseLoosePipeline(tokens, tracer:)],
    else: $ parseArrow(tokens, tracer:),
  )
);

parseConstantFunction = (tokens, tracer:) => tracer.inBlock(
  "constant function",
  $ (
    [body, tail] = parseAssignable(tokens.next(), tracer:);
    [ast/constantFunction(body), tail]
  )
);

parseLoosePipeline = (tokens, tracer:) => tracer.inBlock(
  "loose pipeline",
  $ (
    [steps, tails] = parseLoosePipelineStep(tokens, tracer:)
    | build(([_, tokens]) => (
      parseLoosePipelineStep(tokens, tracer:)
    ))
    | continueIf(([_, tokens]) => (
      tokens | firstType | eqOneOf("PIPE_DOT", "PIPE", "AT")
    ))
    | unzip;
    [ast/loosePipeline(*steps), tails | last]
  )
);

parseArrow = (tokens, tracer:) => tracer.inBlock(
  "arrow",
  $ (
    [start, tail] = parseLoosePipelineCall(tokens, tracer:);
    start.type | switch(
      ["mixedParamList", $ (
        if(
          tail | firstType | eq("ARROW"),
          then: $ (
            [result, resultTail] = parseAssignable(tail.next(), tracer:);
            [ast/arrow(start, result), resultTail]
          ),
          else: $ errorAtToken("expectedArrow", tail.value()),
        )
      )],
      ["group", $ (
        if(
          tail | firstType | eq("ARROW"),
          then: $ (
            [result, resultTail] = parseAssignable(tail.next(), tracer:);
            [ast/arrow(start | groupToParameterList, result), resultTail]
          ),
          else: $ [start, tail],
        )
      )],
      else: $ [start, tail],
    )
  )
);

groupToParameterList = (group) => (
  ast/mixedParamList(group.expression | expressionToParameter)
);

expressionToParameter = (expression) => (
  expression | expressionToNamePattern
);

parseLoosePipelineCall = (tokens, tracer:) => tracer.inBlock(
  "loose pipeline call",
  $ (
    [[start, *steps], tails] = parseTightPipelineCall(tokens, tracer:)
    | build(([_, tokens]) => (
      parseLoosePipelineStep(tokens, tracer:)
    ))
    | continueIf(([_, tokens]) => (
      tokens | firstType | eqOneOf("PIPE_DOT", "PIPE", "AT")
    ))
    | unzip;
    call = if(
      steps | isEmpty,
      then: $ start,
      else: $ (
        pipeline = ast/loosePipeline(*steps);
        ast/pipelineCall(start, pipeline)
      ),
    );
    [call, tails | last]
  )
);

parseLoosePipelineStep = (tokens, tracer:) => tracer.inBlock(
  "loose pipeline step",
  $ (
    tokens | firstType | switch(
      ["PIPE_DOT", $ (
        [name, nameTail] = parseName(tokens.next(), tracer:);
        [steps, stepsTail] = parseTightPipelineSteps(nameTail, tracer:);
        [ast/pipeDot(name, *steps), stepsTail]
      )],
      ["PIPE", $ (
        [callee, calleeTail] = parseTightPipelineCall(tokens.next(), tracer:);
        [ast/pipe(callee), calleeTail]
      )],
      else: $ (
        [index, indexTail] = parseTightPipelineCall(tokens.next(), tracer:);
        [ast/at(index), indexTail]
      ),
    )
  )
);

parseTightPipelineCall = (tokens, tracer:) => tracer.inBlock(
  "tight pipeline call",
  $ (
    [start, tail] = parseAtomic(tokens, tracer:);
    [steps, stepTail] = parseTightPipelineSteps(tail, tracer:);
    call = if(
      steps | isEmpty,
      then: $ start,
      else: $ (
        pipeline = ast/tightPipeline(*steps);
        ast/pipelineCall(start, pipeline)
      ),
    );
    [call, stepTail]
  )
);

parseTightPipelineSteps = (tokens, tracer:) => (
  [steps, tails] = [null, tokens]
  | build(([_, tokens]) => (
    parseTightPipelineStep(tokens, tracer:)
  ))
  | continueIf(([_, tokens]) => (
    tokens | firstType | eqOneOf("DOT", "OPEN_PAREN")
  ))
  | unzip;
  [steps | dropFirst, tails | last]
);

parseTightPipelineStep = (tokens, tracer:) => tracer.inBlock(
  "tight pipeline step",
  $ (
    if(
      tokens | firstType | eq("DOT"),
      then: $ (
        [name, nameEnd] = parseName(tokens.next(), tracer:);
        [ast/dot(ast/literal(name.name)), nameEnd]
      ),
      else: $ (
        [args, tail] = parseArgumentList(tokens, tracer:);
        [ast/args(args), tail]
      )
    )
  )
);

parseArgumentList = (tokens, tracer:) => tracer.inBlock(
  "argument list",
  $ (
    contentTokens = tokens.next();
    if(
      contentTokens | firstType | eq("CLOSE_PAREN"),
      then: $ [ast/mixedArgList(), contentTokens.next()],
      else: $ (
        [args, tails] = parseEntry(contentTokens, tracer:)
        | build(([_, tokens]) => (
          parseEntry(tokens.next(), tracer:)
        ))
        | continueIf(([_, tokens]) => (
          tokens | firstType | eq("COMMA") | and(
            $ tokens @ 2 |.type | eq("CLOSE_PAREN") | not
          )
        ))
        | unzip;
        tail = tails | last | skipIfPresent("COMMA");
        if(
          tail | firstType | eq("CLOSE_PAREN"),
          then: $ [ast/mixedArgList(*args), tail.next()],
          else: $ errorAtToken("unclosedArguments", tail.value()),
        )
      )
    )
  )
);

parseAtomic = (tokens, tracer:) => (
  token = tokens.value();
  token.type | switch(
    ["OPEN_PAREN", $ parseGroup(tokens, tracer:)],
    ["OPEN_BRACKET", $ parseArray(tokens, tracer:)],
    ["STAR", $ parseArraySpread(tokens, tracer:)],
    ["OPEN_BRACE", $ parseObject(tokens, tracer:)],
    ["DOUBLE_STAR", $ parseObjectSpread(tokens, tracer:)],
    ["LITERAL", $ parseLiteral(tokens, tracer:)],
    ["NAME", $ parseName(tokens, tracer:)],
    ["UNDERSCORE", $ [ast/ignore(), tokens.next()]],
    else: $ errorAtToken("unexpectedToken", token, type: token.type)
  )
);

parseGroup = (tokens, tracer:) => tracer.inBlock(
  "group",
  $ (
    parseEnclosedList(
      tokens,
      parseElement: parseExpression,
      makeNode: (*elements) => (
        if (
          elements | length | eq(1),
          then: $ ast/group(elements | first),
          else: $ ast/mixedParamList(*(elements | transform(expressionToParameter))),
        )
      ),
      terminator: "CLOSE_PAREN",
      onUnclosed: (token) => errorAtToken("unclosedGroup", token),
      tracer:
    )
  )
);

parseArray = (tokens, tracer:) => tracer.inBlock(
  "array",
  $ (
    parseEnclosedList(
      tokens,
      parseElement: parseStatement,
      makeNode: ast/array,
      terminator: "CLOSE_BRACKET",
      onUnclosed: (token) => errorAtToken("unclosedArray", token),
      tracer:,
    )
  )
);

parseArraySpread = (tokens, tracer:) => tracer.inBlock(
  "array spread",
  $ (
    [expr, tail] = parseAtomic(tokens.next(), tracer:);
    [ast/arraySpread(expr), tail]
  )
);

parseObject = (tokens, tracer:) => tracer.inBlock(
  "object",
  $ (
    contentTokens = tokens.next();
    if(
      contentTokens | firstType | eq("CLOSE_BRACE"),
      then: $ [ast/object(), contentTokens.next()],
      else: $ (
        [entries, tails] = parseStatement(contentTokens, tracer:)
        | build(([_, tokens]) => (
          parseStatement(tokens.next(), tracer:)
        ))
        | continueIf(([_, tokens]) => (
          tokens | firstType | eq("COMMA") | and(
            $ tokens @ 2 |.type | eq("CLOSE_BRACE") | not
          )
        ))
        | unzip;
        tail = tails | last | skipIfPresent("COMMA");
        if(
          tail | firstType | eq("CLOSE_BRACE"),
          then: $ [ast/object(*entries), tail.next()],
          else: $ errorAtToken("unclosedObject", tail.value())
        )
      )
    )
  )
);

parseObjectSpread = (tokens, tracer:) => tracer.inBlock(
  "object spread",
  $ (
    [expr, tail] = parseAtomic(tokens.next(), tracer:);
    [ast/objectSpread(expr), tail]
  )
);

parseLiteral = (tokens, tracer:) => tracer.inBlock(
  "literal",
  $ (
    token = tokens.value();
    tracer.log(
      $ (
        ["Matched literal ", token.value | display, " at ", formatLineColumn(token)]
        | join
      )
    );
    [ast/literal(token.value), tokens.next()]
  )
);

parseName = (tokens, tracer:) => tracer.inBlock(
  "name",
  $ if(
    tokens.next() | firstType | eq("SLASH"),
    then: $ parseNameInModule(tokens, tracer:),
    else: $ (
      token = tokens.value();
      name = token.text;
      tracer.log(
        $ (
          ["Matched name ", name, " at ", formatLineColumn(token)]
          | join
        )
      );
      [ast/name(name), tokens.next()]
    ),
  )
);

parseNameInModule = (tokens, tracer:) => (
  moduleToken = tokens.value();
  moduleName = moduleToken.text;
  tail = tokens | dropFirst(2);
  innerToken = tail.value();
  innerName = innerToken.text;
  if(
    innerToken.type | eq("NAME"),
    then: $ (
      tracer.log(
        $ (
          ["Matched name ", moduleName, "/", innerName, " at ", formatLineColumn(moduleToken)]
          | join
        )
      );
      [ast/nameInModule(moduleName, innerName), tail.next()]
    ),
    else: $ errorAtToken("expectedName", innerToken)
  )
);

parseEnclosedList = (
  tokens,
  parseElement:,
  makeNode:,
  terminator:,
  onUnclosed:,
  tracer:,
) => (
  contentTokens = tokens.next();
  if(
    contentTokens | firstType | eq(terminator),
    then: $ [makeNode(), contentTokens.next()],
    else: $ (
      [elements, tails] = parseElement(contentTokens, tracer:)
      | build(([_, tokens]) => (
        parseElement(tokens.next(), tracer:)
      ))
      | continueIf(([_, tokens]) => (
        tokens | firstType | eq("COMMA") | and(
          $ tokens @ 2 |.type | eq(terminator) | not
        )
      ))
      | unzip;
      tail = tails | last | skipIfPresent("COMMA");
      if(
        tail | firstType | eq(terminator),
        then: $ [makeNode(*elements), tail.next()],
        else: $ onUnclosed(tail.value()),
      )
    )
  )
);

skipIfPresent = (tokens, type) => (
  tokens | butIf(| firstType | eq(type), |.next())
);

firstType = (tokens) => tokens.value().type;

formatLineColumn = (token) => (
  [token.line, token.column] | transform(display) | join(on: ":")
);

validateExpression = (expression) => (
  expression
);

errorAtToken = (type, token, **properties) => (
  error(type, line: token.line, column: token.column, **properties)
);

error = (type, line:, column:, **properties) => (
  throw(newError(type, line:, column:, **properties))
);
