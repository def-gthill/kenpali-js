parse = (code, trace: = "false") => (
  tokens = lexer/lex(code) | toArray;
  ast = parseExpression(tokens, 0);
  if(
    tokens @ ast.end |.type | eq("EOF"),
    then: $ desugarer/desugar(ast.ast),
    else: $ error("unparsedInput", line: tokens @ ast.end |.line, column: tokens @ ast.end |.column),
  )
);

parseModule = (code, trace: = "false") => (
  tokens = lexer/lex(code) | toArray;
  definitions = parseModuleDefinitions(tokens, 0);
  if(
    tokens @ definitions.end |.type | eq("EOF"),
    then: $ definitions.definitions | transform(([name, value]) => [name.name, desugarer/desugar(value)]),
    else: $ error("unparsedInput", line: tokens @ definitions.end |.line, column: tokens @ definitions.end |.column),
  )
);

parseModuleDefinitions = (tokens, index) => (
  [definitions, definitionsEnd] = parseModuleDefinitionsLoop(tokens, index, []);
  {definitions: definitions, end: definitionsEnd}
);

parseModuleDefinitionsLoop = (tokens, index, definitions) => (
  if(
    tokens @ index |.type | eq("EOF"),
    then: $ [definitions, index],
    else: $ (
      [def, statementEnd] = parseStatement(tokens, index);
      if(
        tokens @ statementEnd |.type | eq("SEMICOLON"),
        then: $ (
          semicolonEnd = statementEnd | add(1);
          parseModuleDefinitionsLoop(tokens, semicolonEnd, definitions | add(def))
        ),
        else: $ [definitions | add(def), statementEnd],
      )
    ),
  )
);

parseExpression = (tokens, index) => (
  parseScope(tokens, index)
);

parseScope = (tokens, index) => (
  [statements, statementEnd] = parseStatements(tokens, index, []);
  [result, assignableEnd] = parseAssignable(tokens, statementEnd);
  if(
    statements | length | eq(0),
    then: $ {ast: result, end: assignableEnd},
    else: $ {ast: {type: "block", defs: statements, result: result}, end: assignableEnd},
  )
);

parseStatements = (tokens, index, statements) => (
  if(
    tokens @ index |.type | eq("EOF"),
    then: $ [statements, index],
    else: $ (
      token = tokens @ index;
      if(
        token.type | eq("SEMICOLON"),
        then: $ [statements, index],
        else: $ (
          [def, statementEnd] = parseStatement(tokens, index);
          if(
            tokens @ statementEnd |.type | eq("SEMICOLON"),
            then: $ (
              semicolonEnd = statementEnd | add(1);
              parseStatements(tokens, semicolonEnd, statements | add(def))
            ),
            else: $ [statements | add(def), statementEnd],
          )
        ),
      )
    ),
  )
);

parseStatement = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("NAME") | or($ token.type | eq("UNDERSCORE") | or($ token.type | eq("OPEN_BRACKET") | or($ token.type | eq("OPEN_BRACE")))),
    then: $ (
      [target, patternEnd] = parseNamePattern(tokens, index);
      if(
        tokens @ patternEnd |.type | eq("EQUALS"),
        then: $ (
          equalsEnd = patternEnd | add(1);
          [value, assignableEnd] = parseAssignable(tokens, equalsEnd);
          [[target, value], assignableEnd]
        ),
        else: $ (
          [value, assignableEnd] = parseAssignable(tokens, patternEnd);
          [[null, value], assignableEnd]
        ),
      )
    ),
    else: $ (
      [value, assignableEnd] = parseAssignable(tokens, index);
      [[null, value], assignableEnd]
    ),
  )
);

parseNamePattern = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("UNDERSCORE"),
    then: $ (
      underscoreEnd = index | add(1);
      [{type: "ignore"}, underscoreEnd]
    ),
    else: $ if(
      token.type | eq("OPEN_BRACKET"),
      then: $ parseArrayPattern(tokens, index),
      else: $ if(
        token.type | eq("OPEN_BRACE"),
        then: $ parseObjectPattern(tokens, index),
        else: $ parseName(tokens, index),
      ),
    ),
  )
);

parseArrayPattern = (tokens, index) => (
  bracketStart = index | add(1);
  [elements, elementsEnd] = parseArrayPatternElements(tokens, bracketStart, []);
  if(
    tokens @ elementsEnd |.type | eq("CLOSE_BRACKET"),
    then: $ (
      bracketEnd = elementsEnd | add(1);
      [{type: "arrayPattern", names: elements}, bracketEnd]
    ),
    else: $ error("unclosedArrayPattern", line: tokens @ elementsEnd |.line, column: tokens @ elementsEnd |.column),
  )
);

parseArrayPatternElements = (tokens, index, elements) => (
  if(
    tokens @ index |.type | eq("CLOSE_BRACKET"),
    then: $ [elements, index],
    else: $ (
      [element, elementEnd] = parseArrayPatternElement(tokens, index);
      if(
        tokens @ elementEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = elementEnd | add(1);
          parseArrayPatternElements(tokens, commaEnd, elements | add(element))
        ),
        else: $ [elements | add(element), elementEnd],
      )
    ),
  )
);

parseArrayPatternElement = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("STAR"),
    then: $ (
      starEnd = index | add(1);
      [pattern, patternEnd] = parseNamePattern(tokens, starEnd);
      [{type: "arrayRest", name: pattern}, patternEnd]
    ),
    else: $ if(
      tokens @ (index | add(1)) |.type | eq("EQUALS"),
      then: $ (
        [pattern, patternEnd] = parseNamePattern(tokens, index);
        equalsEnd = patternEnd | add(1);
        [defaultValue, defaultValueEnd] = parseAssignable(tokens, equalsEnd);
        [{type: "optional", name: pattern, defaultValue: defaultValue}, defaultValueEnd]
      ),
      else: $ parseNamePattern(tokens, index),
    ),
  )
);

parseObjectPattern = (tokens, index) => (
  braceStart = index | add(1);
  [elements, elementsEnd] = parseObjectPatternElements(tokens, braceStart, []);
  if(
    tokens @ elementsEnd |.type | eq("CLOSE_BRACE"),
    then: $ (
      braceEnd = elementsEnd | add(1);
      [{type: "objectPattern", entries: elements}, braceEnd]
    ),
    else: $ error("unclosedObjectPattern", line: tokens @ elementsEnd |.line, column: tokens @ elementsEnd |.column),
  )
);

parseObjectPatternElements = (tokens, index, elements) => (
  if(
    tokens @ index |.type | eq("CLOSE_BRACE"),
    then: $ [elements, index],
    else: $ (
      [element, elementEnd] = parseObjectPatternElement(tokens, index);
      if(
        tokens @ elementEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = elementEnd | add(1);
          parseObjectPatternElements(tokens, commaEnd, elements | add(element))
        ),
        else: $ [elements | add(element), elementEnd],
      )
    ),
  )
);

parseObjectPatternElement = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("DOUBLE_STAR"),
    then: $ (
      starEnd = index | add(1);
      [pattern, patternEnd] = parseNamePattern(tokens, starEnd);
      [{type: "objectRest", name: pattern}, patternEnd]
    ),
    else: $ if(
      tokens @ (index | add(1)) |.type | eq("COLON"),
      then: $ (
        [key, keyEnd] = parseAssignable(tokens, index);
        colonEnd = keyEnd | add(1);
        [pattern, patternEnd] = parseNamePattern(tokens, colonEnd);
        [{type: "entry", key: key, value: pattern}, patternEnd]
      ),
      else: $ if(
        tokens @ (index | add(1)) |.type | eq("EQUALS"),
        then: $ (
          [simple, simpleEnd] = parseObjectPatternSimple(tokens, index);
          equalsEnd = simpleEnd | add(1);
          [defaultValue, defaultValueEnd] = parseAssignable(tokens, equalsEnd);
          [{type: "optional", name: simple, defaultValue: defaultValue}, defaultValueEnd]
        ),
        else: $ (
          parseObjectPatternSimple(tokens, index)
        ),
      ),
    ),
  )
);

parseObjectPatternSimple = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("NAME"),
    then: $ (
      nameStart = index | add(1);
      if(
        tokens @ nameStart |.type | eq("COLON"),
        then: $ (
          name = token.text;
          colonEnd = nameStart | add(1);
          [pattern, patternEnd] = parseNamePattern(tokens, colonEnd);
          [{type: "keyName", key: {type: "name", name: name}}, patternEnd]
        ),
        else: $ [{type: "name", name: token.text}, nameStart],
      )
    ),
    else: $ error("expectedObjectPatternSimple", line: token.line, column: token.column),
  )
);

parseAssignable = (tokens, index) => (
  parseArrowFunction(tokens, index)
);

parseArrowFunction = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("OPEN_PAREN"),
    then: $ (
      [params, paramsEnd] = parseParameterList(tokens, index);
      if(
        tokens @ paramsEnd |.type | eq("ARROW"),
        then: $ (
          arrowEnd = paramsEnd | add(1);
          [body, bodyEnd] = parseAssignable(tokens, arrowEnd);
          [{type: "arrow", params: params, body: body}, bodyEnd]
        ),
        else: $ error("expectedArrowFunction", line: tokens @ paramsEnd |.line, column: tokens @ paramsEnd |.column),
      )
    ),
    else: $ (
      [result, resultEnd] = parseLoosePipelineCall(tokens, index);
      if(
        tokens @ resultEnd |.type | eq("ARROW"),
        then: $ (
          arrowEnd = resultEnd | add(1);
          [body, bodyEnd] = parseAssignable(tokens, arrowEnd);
          params = {type: "mixedParamList", params: []};
          [{type: "arrow", params: params, body: body}, bodyEnd]
        ),
        else: $ [result, resultEnd],
      )
    ),
  )
);

parseParameterList = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("OPEN_PAREN"),
    then: $ (
      parenStart = index | add(1);
      [params, paramsEnd] = parseParameters(tokens, parenStart, []);
      if(
        tokens @ paramsEnd |.type | eq("CLOSE_PAREN"),
        then: $ (
          parenEnd = paramsEnd | add(1);
          [{type: "mixedParamList", params: params}, parenEnd]
        ),
        else: $ error("unclosedParameters", line: tokens @ paramsEnd |.line, column: tokens @ paramsEnd |.column),
      )
    ),
    else: $ error("expectedParameterList", line: token.line, column: token.column),
  )
);

parseParameters = (tokens, index, params) => (
  if(
    tokens @ index |.type | eq("CLOSE_PAREN"),
    then: $ [params, index],
    else: $ (
      [param, paramEnd] = parseParameter(tokens, index);
      if(
        tokens @ paramEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = paramEnd | add(1);
          parseParameters(tokens, commaEnd, params | add(param))
        ),
        else: $ [params | add(param), paramEnd],
      )
    ),
  )
);

parseParameter = (tokens, index) => (
  parseObjectPatternElement(tokens, index)
);

parseLoosePipelineCall = (tokens, index) => (
  [start, startEnd] = parseTightPipelineCall(tokens, index);
  if(
    tokens @ startEnd |.type | eq("PIPE") | or($ tokens @ startEnd |.type | eq("PIPE_DOT") | or($ tokens @ startEnd |.type | eq("AT"))),
    then: $ (
      [pipeline, pipelineEnd] = parseLoosePipeline(tokens, startEnd);
      [{type: "pipelineCall", start: start, pipeline: pipeline}, pipelineEnd]
    ),
    else: $ [start, startEnd],
  )
);

parseLoosePipeline = (tokens, index) => (
  [steps, stepsEnd] = parseLoosePipelineSteps(tokens, index, []);
  [{type: "loosePipeline", steps: steps}, stepsEnd]
);

parseLoosePipelineSteps = (tokens, index, steps) => (
  token = tokens @ index;
  if(
    token.type | eq("PIPE") | or($ token.type | eq("PIPE_DOT") | or($ token.type | eq("AT"))),
    then: $ (
      [step, stepEnd] = parseLoosePipelineStep(tokens, index);
      parseLoosePipelineSteps(tokens, stepEnd, steps | add(step))
    ),
    else: $ [steps, index],
  )
);

parseLoosePipelineStep = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("PIPE_DOT"),
    then: $ (
      dotStart = index | add(1);
      [name, nameEnd] = parseName(tokens, dotStart);
      [tightSteps, stepsEnd] = parseTightPipelineSteps(tokens, nameEnd, []);
      [{type: "pipeDot", index: {type: "literal", value: name.name}, steps: tightSteps}, stepsEnd]
    ),
    else: $ if(
      token.type | eq("PIPE"),
      then: $ (
        pipeStart = index | add(1);
        [callee, calleeEnd] = parseTightPipelineCall(tokens, pipeStart);
        [{type: "pipe", callee: callee}, calleeEnd]
      ),
      else: $ (
        atStart = index | add(1);
        [idx, idxEnd] = parseTightPipelineCall(tokens, atStart);
        [{type: "at", index: idx}, idxEnd]
      ),
    ),
  )
);

parseTightPipelineCall = (tokens, index) => (
  [start, startEnd] = parseAtomic(tokens, index);
  [tightSteps, stepsEnd] = parseTightPipelineSteps(tokens, startEnd, []);
  if(
    tightSteps | length | gt(0),
    then: $ (
      pipeline = {type: "tightPipeline", steps: tightSteps};
      [{type: "pipelineCall", start: start, pipeline: pipeline}, stepsEnd]
    ),
    else: $ [start, stepsEnd],
  )
);

parseTightPipelineSteps = (tokens, index, steps) => (
  token = tokens @ index;
  if(
    token.type | eq("DOT") | or($ token.type | eq("OPEN_PAREN")),
    then: $ (
      [step, stepEnd] = parseTightPipelineStep(tokens, index);
      parseTightPipelineSteps(tokens, stepEnd, steps | add(step))
    ),
    else: $ [steps, index],
  )
);

parseTightPipelineStep = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("DOT"),
    then: $ (
      dotStart = index | add(1);
      [name, nameEnd] = parseName(tokens, dotStart);
      [{type: "dot", index: {type: "literal", value: name.name}}, nameEnd]
    ),
    else: $ (
      parseArgumentList(tokens, index)
    ),
  )
);

parseAtomic = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("OPEN_PAREN"),
    then: $ parseGroup(tokens, index),
    else: $ if(
      token.type | eq("OPEN_BRACKET"),
      then: $ parseArray(tokens, index),
      else: $ if(
        token.type | eq("OPEN_BRACE"),
        then: $ parseObject(tokens, index),
        else: $ if(
          token.type | eq("LITERAL"),
          then: $ parseLiteral(tokens, index),
          else: $ if(
            token.type | eq("DOLLAR"),
            then: $ parseConstantFunction(tokens, index),
            else: $ parseName(tokens, index),
          ),
        ),
      ),
    ),
  )
);

parseGroup = (tokens, index) => (
  parenStart = index | add(1);
  [expr, exprEnd] = parseExpression(tokens, parenStart);
  if(
    tokens @ exprEnd |.type | eq("CLOSE_PAREN"),
    then: $ (
      parenEnd = exprEnd | add(1);
      [{type: "group", expression: expr}, parenEnd]
    ),
    else: $ error("unclosedGroup", line: tokens @ exprEnd |.line, column: tokens @ exprEnd |.column),
  )
);

parseArray = (tokens, index) => (
  bracketStart = index | add(1);
  [elements, elementsEnd] = parseArrayElements(tokens, bracketStart, []);
  if(
    tokens @ elementsEnd |.type | eq("CLOSE_BRACKET"),
    then: $ (
      bracketEnd = elementsEnd | add(1);
      [{type: "array", elements: elements}, bracketEnd]
    ),
    else: $ error("unclosedArray", line: tokens @ elementsEnd |.line, column: tokens @ elementsEnd |.column),
  )
);

parseArrayElements = (tokens, index, elements) => (
  if(
    tokens @ index |.type | eq("CLOSE_BRACKET"),
    then: $ [elements, index],
    else: $ (
      [element, elementEnd] = parseArrayElement(tokens, index);
      if(
        tokens @ elementEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = elementEnd | add(1);
          parseArrayElements(tokens, commaEnd, elements | add(element))
        ),
        else: $ [elements | add(element), elementEnd],
      )
    ),
  )
);

parseArrayElement = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("STAR"),
    then: $ (
      starEnd = index | add(1);
      [value, valueEnd] = parseAssignable(tokens, starEnd);
      [{type: "arraySpread", value: value}, valueEnd]
    ),
    else: $ parseAssignable(tokens, index),
  )
);

parseObject = (tokens, index) => (
  braceStart = index | add(1);
  [entries, entriesEnd] = parseObjectElements(tokens, braceStart, []);
  if(
    tokens @ entriesEnd |.type | eq("CLOSE_BRACE"),
    then: $ (
      braceEnd = entriesEnd | add(1);
      [{type: "object", entries: entries}, braceEnd]
    ),
    else: $ error("unclosedObject", line: tokens @ entriesEnd |.line, column: tokens @ entriesEnd |.column),
  )
);

parseObjectElements = (tokens, index, entries) => (
  if(
    tokens @ index |.type | eq("CLOSE_BRACE"),
    then: $ [entries, index],
    else: $ (
      [entry, entryEnd] = parseObjectElement(tokens, index);
      if(
        tokens @ entryEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = entryEnd | add(1);
          parseObjectElements(tokens, commaEnd, entries | add(entry))
        ),
        else: $ [entries | add(entry), entryEnd],
      )
    ),
  )
);

parseObjectElement = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("DOUBLE_STAR"),
    then: $ (
      starEnd = index | add(1);
      [value, valueEnd] = parseAssignable(tokens, starEnd);
      [{type: "objectSpread", value: value}, valueEnd]
    ),
    else: $ if(
      tokens @ (index | add(1)) |.type | eq("COLON"),
      then: $ (
        [key, keyEnd] = parseAssignable(tokens, index);
        colonEnd = keyEnd | add(1);
        [value, valueEnd] = parseAssignable(tokens, colonEnd);
        [{type: "entry", key: key, value: value}, valueEnd]
      ),
      else: $ (
        [name, nameEnd] = parseName(tokens, index);
        if(
          tokens @ nameEnd |.type | eq("COLON"),
          then: $ (
            colonEnd = nameEnd | add(1);
            [value, valueEnd] = parseAssignable(tokens, colonEnd);
            [{type: "entry", key: {type: "keyName", key: name}, value: value}, valueEnd]
          ),
          else: $ (
            [{type: "keyName", key: name}, nameEnd]
          ),
        )
      ),
    ),
  )
);

parseLiteral = (tokens, index) => (
  token = tokens @ index;
  literalEnd = index | add(1);
  [{type: "literal", value: token.value}, literalEnd]
);

parseConstantFunction = (tokens, index) => (
  dollarEnd = index | add(1);
  [body, bodyEnd] = parseAssignable(tokens, dollarEnd);
  [{type: "constantFunction", body: body}, bodyEnd]
);

parseName = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("NAME"),
    then: $ (
      nameStart = index | add(1);
      if(
        tokens @ nameStart |.type | eq("SLASH"),
        then: $ (
          moduleName = token.text;
          slashEnd = nameStart | add(1);
          nameToken = tokens @ slashEnd;
          if(
            nameToken.type | eq("NAME"),
            then: $ (
              nameEnd = slashEnd | add(1);
              [{type: "name", name: nameToken.text, from: moduleName}, nameEnd]
            ),
            else: $ error("expectedNameInModule", line: nameToken.line, column: nameToken.column),
          )
        ),
        else: $ [{type: "name", name: token.text}, nameStart],
      )
    ),
    else: $ error("expectedName", line: token.line, column: token.column),
  )
);

parseArgumentList = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("OPEN_PAREN"),
    then: $ (
      parenStart = index | add(1);
      [args, argsEnd] = parseArguments(tokens, parenStart, []);
      if(
        tokens @ argsEnd |.type | eq("CLOSE_PAREN"),
        then: $ (
          parenEnd = argsEnd | add(1);
          [{type: "mixedArgList", args: args}, parenEnd]
        ),
        else: $ error("unclosedArguments", line: tokens @ argsEnd |.line, column: tokens @ argsEnd |.column),
      )
    ),
    else: $ error("expectedArguments", line: token.line, column: token.column),
  )
);

parseArguments = (tokens, index, args) => (
  if(
    tokens @ index |.type | eq("CLOSE_PAREN"),
    then: $ [args, index],
    else: $ (
      [arg, argEnd] = parseArgument(tokens, index);
      if(
        tokens @ argEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = argEnd | add(1);
          parseArguments(tokens, commaEnd, args | add(arg))
        ),
        else: $ [args | add(arg), argEnd],
      )
    ),
  )
);

parseArgument = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("STAR"),
    then: $ (
      starEnd = index | add(1);
      [value, valueEnd] = parseAssignable(tokens, starEnd);
      [{type: "arraySpread", value: value}, valueEnd]
    ),
    else: $ if(
      token.type | eq("DOUBLE_STAR"),
      then: $ (
        starEnd = index | add(1);
        [value, valueEnd] = parseAssignable(tokens, starEnd);
        [{type: "objectSpread", value: value}, valueEnd]
      ),
      else: $ if(
        tokens @ (index | add(1)) |.type | eq("COLON"),
        then: $ (
          [key, keyEnd] = parseAssignable(tokens, index);
          colonEnd = keyEnd | add(1);
          [value, valueEnd] = parseAssignable(tokens, colonEnd);
          [{type: "entry", key: key, value: value}, valueEnd]
        ),
          else: $ if(
            token.type | eq("NAME") | and($ tokens @ (index | add(1)) |.type | eq("COLON")),
            then: $ (
              [name, nameEnd] = parseName(tokens, index);
              colonEnd = nameEnd | add(1);
              [value, valueEnd] = parseAssignable(tokens, colonEnd);
              [{type: "entry", key: {type: "keyName", key: name}, value: value}, valueEnd]
            ),
          else: $ parseAssignable(tokens, index),
        ),
      ),
    ),
  )
);

error = (type, line:, column:, character: = null) => (
  // Error creation - this will need to be handled properly
  null
);
