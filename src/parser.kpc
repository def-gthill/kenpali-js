parse = (code, trace: = false) => (
  tracer = getTracer(trace);
  tokens = lexer/lex(code) | toArray;
  ast = tracer.inBlock("parse", $ parseExpression(tokens, 1, tracer:));
  if(
    tokens @ ast.end |.type | eq("EOF"),
    then: $ desugarer/desugar(ast.ast),
    else: $ error("unparsedInput", line: tokens @ ast.end |.line, column: tokens @ ast.end |.column),
  )
);

parseModule = (code, trace: = false) => (
  tracer = getTracer(trace);
  tokens = lexer/lex(code) | toArray;
  definitions = parseModuleDefinitions(tokens, 1);
  if(
    tokens @ definitions.end |.type | eq("EOF"),
    then: $ definitions.definitions | transform(([name, value]) => [name.name, desugarer/desugar(value)]),
    else: $ error("unparsedInput", line: tokens @ definitions.end |.line, column: tokens @ definitions.end |.column),
  )
);

getTracer = (trace) => if(trace, then: newTracer, else: $ dummyTracer);

newTracer = $ (
  indent = newVar(0);
  self = {
    inBlock: (name, f) => (
      self.log(["Begin ", name] | join);
      indent.get() | up | indent.set;
      result = f();
      indent.get() | down | indent.set;
      self.log(["End ", name] | join);
      result
    ),
    log: (value) => (
      [
        *("| " | repeat | keepFirst(indent.get())),
        value,
      ]
      | join
      | write
    )
  };
  self
);

dummyTracer = {
  inBlock: (_, f) => f(),
  log: $ null,
};

parseModuleDefinitions = (tokens, index) => (
  [definitions, definitionsEnd] = parseModuleDefinitionsLoop(tokens, index, []);
  {definitions: definitions, end: definitionsEnd}
);

parseModuleDefinitionsLoop = (tokens, index, definitions) => (
  if(
    tokens @ index |.type | eq("EOF"),
    then: $ [definitions, index],
    else: $ (
      [def, statementEnd] = parseStatement(tokens, index);
      if(
        tokens @ statementEnd |.type | eq("SEMICOLON"),
        then: $ (
          semicolonEnd = statementEnd | add(1);
          parseModuleDefinitionsLoop(tokens, semicolonEnd, definitions | add(def))
        ),
        else: $ [definitions | add(def), statementEnd],
      )
    ),
  )
);

parseExpression = (tokens, index, tracer: = dummyTracer) => (
  parseScope(tokens, index, tracer:)
);

parseScope = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "scope",
    $ (
    [[*statements, [target, result]], statementEnd] = parseStatements(tokens, index, [], tracer:);
    if(
      target | isNull | not, // Result is an assignment
      then: $ error("expectedStatementSeparator", line: tokens @ statementEnd |.line, column: tokens @ statementEnd |.column)
    );
    if(
      statements | isEmpty,
      then: $ {ast: result, end: statementEnd},
      else: $ {ast: {type: "block", defs: statements, result: result}, end: statementEnd},
    )
  )
);

parseStatements = (tokens, index, statements, tracer: = dummyTracer) => (
  if(
    tokens @ index |.type | eq("EOF"),
    then: $ [statements, index],
    else: $ (
      token = tokens @ index;
      if(
        token.type | eq("SEMICOLON"),
        then: $ [statements, index],
        else: $ (
          [def, statementEnd] = parseStatement(tokens, index, tracer:);
          if(
            tokens @ statementEnd |.type | eq("SEMICOLON"),
            then: $ (
              semicolonEnd = statementEnd | add(1);
              parseStatements(tokens, semicolonEnd, statements | add(def), tracer:)
            ),
            else: $ [[*statements, def], statementEnd],
          )
        ),
      )
    ),
  )
);

parseStatement = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "statement",
  $ (
    token = tokens @ index;
    if(
      token.type | eq("NAME") | or($ token.type | eq("UNDERSCORE") | or($ token.type | eq("OPEN_BRACKET") | or($ token.type | eq("OPEN_BRACE")))),
      then: $ (
        [target, patternEnd] = parseNamePattern(tokens, index, tracer:);
        if(
          tokens @ patternEnd |.type | eq("EQUALS"),
          then: $ (
            equalsEnd = patternEnd | add(1);
            [value, assignableEnd] = parseAssignable(tokens, equalsEnd, tracer:);
          [[target, value], assignableEnd]
        ),
        else: $ (
          [value, assignableEnd] = parseAssignable(tokens, patternEnd, tracer:);
          [[null, value], assignableEnd]
        ),
      )
    ),
    else: $ (
      [value, assignableEnd] = parseAssignable(tokens, index, tracer:);
        [[null, value], assignableEnd]
      ),
    )
  )
);

parseNamePattern = (tokens, index, tracer: = dummyTracer) => (
  token = tokens @ index;
  if(
    token.type | eq("UNDERSCORE"),
    then: $ (
      underscoreEnd = index | add(1);
      [{type: "ignore"}, underscoreEnd]
    ),
    else: $ if(
      token.type | eq("OPEN_BRACKET"),
      then: $ parseArrayPattern(tokens, index),
      else: $ if(
        token.type | eq("OPEN_BRACE"),
        then: $ parseObjectPattern(tokens, index),
        else: $ parseName(tokens, index, tracer:),
      ),
    ),
  )
);

parseArrayPattern = (tokens, index, tracer: = dummyTracer) => (
  bracketStart = index | add(1);
  [elements, elementsEnd] = parseArrayPatternElements(tokens, bracketStart, [], tracer:);
  if(
    tokens @ elementsEnd |.type | eq("CLOSE_BRACKET"),
    then: $ (
      bracketEnd = elementsEnd | add(1);
      [{type: "arrayPattern", names: elements}, bracketEnd]
    ),
    else: $ error("unclosedArrayPattern", line: tokens @ elementsEnd |.line, column: tokens @ elementsEnd |.column),
  )
);

parseArrayPatternElements = (tokens, index, elements, tracer: = dummyTracer) => (
  if(
    tokens @ index |.type | eq("CLOSE_BRACKET"),
    then: $ [elements, index],
    else: $ (
      [element, elementEnd] = parseArrayPatternElement(tokens, index, tracer:);
      if(
        tokens @ elementEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = elementEnd | add(1);
          parseArrayPatternElements(tokens, commaEnd, elements | add(element), tracer:)
        ),
        else: $ [elements | add(element), elementEnd],
      )
    ),
  )
);

parseArrayPatternElement = (tokens, index, tracer: = dummyTracer) => (
  token = tokens @ index;
  if(
    token.type | eq("STAR"),
    then: $ (
      starEnd = index | add(1);
      [pattern, patternEnd] = parseNamePattern(tokens, starEnd, tracer:);
      [{type: "arrayRest", name: pattern}, patternEnd]
    ),
    else: $ if(
      tokens @ (index | add(1)) |.type | eq("EQUALS"),
      then: $ (
        [pattern, patternEnd] = parseNamePattern(tokens, index, tracer:);
        equalsEnd = patternEnd | add(1);
        [defaultValue, defaultValueEnd] = parseAssignable(tokens, equalsEnd, tracer:);
        [{type: "optional", name: pattern, defaultValue: defaultValue}, defaultValueEnd]
      ),
      else: $ parseNamePattern(tokens, index, tracer:),
    ),
  )
);

parseObjectPattern = (tokens, index, tracer: = dummyTracer) => (
  braceStart = index | add(1);
  [elements, elementsEnd] = parseObjectPatternElements(tokens, braceStart, [], tracer:);
  if(
    tokens @ elementsEnd |.type | eq("CLOSE_BRACE"),
    then: $ (
      braceEnd = elementsEnd | add(1);
      [{type: "objectPattern", entries: elements}, braceEnd]
    ),
    else: $ error("unclosedObjectPattern", line: tokens @ elementsEnd |.line, column: tokens @ elementsEnd |.column),
  )
);

parseObjectPatternElements = (tokens, index, elements, tracer: = dummyTracer) => (
  if(
    tokens @ index |.type | eq("CLOSE_BRACE"),
    then: $ [elements, index],
    else: $ (
      [element, elementEnd] = parseObjectPatternElement(tokens, index, tracer:);
      if(
        tokens @ elementEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = elementEnd | add(1);
          parseObjectPatternElements(tokens, commaEnd, elements | add(element), tracer:)
        ),
        else: $ [elements | add(element), elementEnd],
      )
    ),
  )
);

parseObjectPatternElement = (tokens, index, tracer: = dummyTracer) => (
  token = tokens @ index;
  if(
    token.type | eq("DOUBLE_STAR"),
    then: $ (
      starEnd = index | add(1);
      [pattern, patternEnd] = parseNamePattern(tokens, starEnd, tracer:);
      [{type: "objectRest", name: pattern}, patternEnd]
    ),
    else: $ if(
      tokens @ (index | add(1)) |.type | eq("COLON"),
      then: $ (
        [key, keyEnd] = parseAssignable(tokens, index, tracer:);
        colonEnd = keyEnd | add(1);
        [pattern, patternEnd] = parseNamePattern(tokens, colonEnd, tracer:);
        [{type: "entry", key: key, value: pattern}, patternEnd]
      ),
      else: $ if(
        tokens @ (index | add(1)) |.type | eq("EQUALS"),
        then: $ (
          [simple, simpleEnd] = parseObjectPatternSimple(tokens, index, tracer:);
          equalsEnd = simpleEnd | add(1);
          [defaultValue, defaultValueEnd] = parseAssignable(tokens, equalsEnd, tracer:);
          [{type: "optional", name: simple, defaultValue: defaultValue}, defaultValueEnd]
        ),
        else: $ (
          parseObjectPatternSimple(tokens, index, tracer:)
        ),
      ),
    ),
  )
);

parseObjectPatternSimple = (tokens, index, tracer: = dummyTracer) => (
  token = tokens @ index;
  if(
    token.type | eq("NAME"),
    then: $ (
      nameStart = index | add(1);
      if(
        tokens @ nameStart |.type | eq("COLON"),
        then: $ (
          name = token.text;
          colonEnd = nameStart | add(1);
          [pattern, patternEnd] = parseNamePattern(tokens, colonEnd, tracer:);
          [{type: "keyName", key: {type: "name", name: name}}, patternEnd]
        ),
        else: $ [{type: "name", name: token.text}, nameStart],
      )
    ),
    else: $ error("expectedObjectPatternSimple", line: token.line, column: token.column),
  )
);

parseAssignable = (tokens, index, tracer: = dummyTracer) => (
  parseArrowFunction(tokens, index, tracer:)
);

parseArrowFunction = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "arrowFunction",
  $ (
    token = tokens @ index;
    if(
      token.type | eq("OPEN_PAREN"),
      then: $ (
        [params, paramsEnd] = parseParameterList(tokens, index, tracer:);
        if(
          tokens @ paramsEnd |.type | eq("ARROW"),
          then: $ (
            arrowEnd = paramsEnd | add(1);
            [body, bodyEnd] = parseAssignable(tokens, arrowEnd, tracer:);
            [{type: "arrow", params: params, body: body}, bodyEnd]
          ),
          else: $ error("expectedArrowFunction", line: tokens @ paramsEnd |.line, column: tokens @ paramsEnd |.column),
        )
      ),
      else: $ (
        [result, resultEnd] = parseLoosePipelineCall(tokens, index, tracer:);
        if(
          tokens @ resultEnd |.type | eq("ARROW"),
          then: $ (
            arrowEnd = resultEnd | add(1);
            [body, bodyEnd] = parseAssignable(tokens, arrowEnd, tracer:);
            params = {type: "mixedParamList", params: []};
            [{type: "arrow", params: params, body: body}, bodyEnd]
          ),
          else: $ [result, resultEnd],
        )
      ),
    )
  )
);

parseParameterList = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("OPEN_PAREN"),
    then: $ (
      parenStart = index | add(1);
      [params, paramsEnd] = parseParameters(tokens, parenStart, []);
      if(
        tokens @ paramsEnd |.type | eq("CLOSE_PAREN"),
        then: $ (
          parenEnd = paramsEnd | add(1);
          [{type: "mixedParamList", params: params}, parenEnd]
        ),
        else: $ error("unclosedParameters", line: tokens @ paramsEnd |.line, column: tokens @ paramsEnd |.column),
      )
    ),
    else: $ error("expectedParameterList", line: token.line, column: token.column),
  )
);

parseParameters = (tokens, index, params, tracer: = dummyTracer) => (
  if(
    tokens @ index |.type | eq("CLOSE_PAREN"),
    then: $ [params, index],
    else: $ (
      [param, paramEnd] = parseParameter(tokens, index, tracer:);
      if(
        tokens @ paramEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = paramEnd | add(1);
          parseParameters(tokens, commaEnd, params | add(param))
        ),
        else: $ [params | add(param), paramEnd],
      )
    ),
  )
);

parseParameter = (tokens, index, tracer: = dummyTracer) => (
  parseObjectPatternElement(tokens, index, tracer:)
);

parseLoosePipelineCall = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "loosePipelineCall",
  $ (
    [start, startEnd] = parseTightPipelineCall(tokens, index, tracer:);
    if(
      tokens @ startEnd |.type | eq("PIPE") | or($ tokens @ startEnd |.type | eq("PIPE_DOT") | or($ tokens @ startEnd |.type | eq("AT"))),
      then: $ (
        [pipeline, pipelineEnd] = parseLoosePipeline(tokens, startEnd, tracer:);
        [{type: "pipelineCall", start: start, pipeline: pipeline}, pipelineEnd]
      ),
      else: $ [start, startEnd],
    )
  )
);

parseLoosePipeline = (tokens, index, tracer: = dummyTracer) => (
  [steps, stepsEnd] = parseLoosePipelineSteps(tokens, index, [], tracer:);
  [{type: "loosePipeline", steps: steps}, stepsEnd]
);

parseLoosePipelineSteps = (tokens, index, steps, tracer: = dummyTracer) => (
  token = tokens @ index;
  if(
    token.type | eq("PIPE") | or($ token.type | eq("PIPE_DOT") | or($ token.type | eq("AT"))),
    then: $ (
      [step, stepEnd] = parseLoosePipelineStep(tokens, index, tracer:);
      parseLoosePipelineSteps(tokens, stepEnd, steps | add(step), tracer:)
    ),
    else: $ [steps, index],
  )
);

parseLoosePipelineStep = (tokens, index, tracer: = dummyTracer) => (
  token = tokens @ index;
  if(
    token.type | eq("PIPE_DOT"),
    then: $ (
      dotStart = index | add(1);
      [name, nameEnd] = parseName(tokens, dotStart, tracer:);
      [tightSteps, stepsEnd] = parseTightPipelineSteps(tokens, nameEnd, [], tracer:);
      [{type: "pipeDot", index: {type: "literal", value: name.name}, steps: tightSteps}, stepsEnd]
    ),
    else: $ if(
      token.type | eq("PIPE"),
      then: $ (
        pipeStart = index | add(1);
        [callee, calleeEnd] = parseTightPipelineCall(tokens, pipeStart, tracer:);
        [{type: "pipe", callee: callee}, calleeEnd]
      ),
      else: $ (
        atStart = index | add(1);
        [idx, idxEnd] = parseTightPipelineCall(tokens, atStart, tracer:);
        [{type: "at", index: idx}, idxEnd]
      ),
    ),
  )
);

parseTightPipelineCall = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "tightPipelineCall",
  $ (
    [start, startEnd] = parseAtomic(tokens, index, tracer:);
    [tightSteps, stepsEnd] = parseTightPipelineSteps(tokens, startEnd, [], tracer:);
    if(
      tightSteps | length | gt(0),
      then: $ (
        pipeline = {type: "tightPipeline", steps: tightSteps};
        [{type: "pipelineCall", start: start, pipeline: pipeline}, stepsEnd]
      ),
      else: $ [start, stepsEnd],
    )
  )
);

parseTightPipelineSteps = (tokens, index, steps, tracer: = dummyTracer) => (
  token = tokens @ index;
  if(
    token.type | eq("DOT") | or($ token.type | eq("OPEN_PAREN")),
    then: $ (
      [step, stepEnd] = parseTightPipelineStep(tokens, index, tracer:);
      parseTightPipelineSteps(tokens, stepEnd, steps | add(step), tracer:)
    ),
    else: $ [steps, index],
  )
);

parseTightPipelineStep = (tokens, index, tracer: = dummyTracer) => (
  token = tokens @ index;
  if(
    token.type | eq("DOT"),
    then: $ (
      dotStart = index | add(1);
      [name, nameEnd] = parseName(tokens, dotStart, tracer:);
      [{type: "dot", index: {type: "literal", value: name.name}}, nameEnd]
    ),
    else: $ (
      parseArgumentList(tokens, index, tracer:)
    ),
  )
);

parseAtomic = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "atomic",
  $ (
    token = tokens @ index;
    if(
      token.type | eq("OPEN_PAREN"),
      then: $ parseGroup(tokens, index, tracer:),
      else: $ if(
        token.type | eq("OPEN_BRACKET"),
        then: $ parseArray(tokens, index, tracer:),
        else: $ if(
          token.type | eq("OPEN_BRACE"),
          then: $ parseObject(tokens, index, tracer:),
          else: $ if(
            token.type | eq("LITERAL"),
            then: $ parseLiteral(tokens, index, tracer:),
            else: $ if(
              token.type | eq("DOLLAR"),
              then: $ parseConstantFunction(tokens, index, tracer:),
              else: $ parseName(tokens, index, tracer:),
            ),
          ),
        ),
      ),
    )
  )
);

parseGroup = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "group",
  $ (
    parenStart = index | add(1);
    [expr, exprEnd] = parseExpression(tokens, parenStart, tracer:);
    if(
      tokens @ exprEnd |.type | eq("CLOSE_PAREN"),
      then: $ (
        parenEnd = exprEnd | add(1);
        [{type: "group", expression: expr}, parenEnd]
      ),
      else: $ error("unclosedGroup", line: tokens @ exprEnd |.line, column: tokens @ exprEnd |.column),
    )
  )
);

parseArray = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "array",
  $ (
    bracketStart = index | add(1);
    [elements, elementsEnd] = parseArrayElements(tokens, bracketStart, [], tracer:);
    if(
      tokens @ elementsEnd |.type | eq("CLOSE_BRACKET"),
      then: $ (
        bracketEnd = elementsEnd | add(1);
        [{type: "array", elements: elements}, bracketEnd]
      ),
      else: $ error("unclosedArray", line: tokens @ elementsEnd |.line, column: tokens @ elementsEnd |.column),
    )
  )
);

parseArrayElements = (tokens, index, elements, tracer: = dummyTracer) => (
  if(
    tokens @ index |.type | eq("CLOSE_BRACKET"),
    then: $ [elements, index],
    else: $ (
      [element, elementEnd] = parseArrayElement(tokens, index, tracer:);
      if(
        tokens @ elementEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = elementEnd | add(1);
          parseArrayElements(tokens, commaEnd, elements | add(element), tracer:)
        ),
        else: $ [elements | add(element), elementEnd],
      )
    ),
  )
);

parseArrayElement = (tokens, index, tracer: = dummyTracer) => (
  token = tokens @ index;
  if(
    token.type | eq("STAR"),
    then: $ (
      starEnd = index | add(1);
      [value, valueEnd] = parseAssignable(tokens, starEnd, tracer:);
      [{type: "arraySpread", value: value}, valueEnd]
    ),
    else: $ parseAssignable(tokens, index, tracer:),
  )
);

parseObject = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "object",
  $ (
    braceStart = index | add(1);
    [entries, entriesEnd] = parseObjectElements(tokens, braceStart, [], tracer:);
    if(
      tokens @ entriesEnd |.type | eq("CLOSE_BRACE"),
      then: $ (
        braceEnd = entriesEnd | add(1);
        [{type: "object", entries: entries}, braceEnd]
      ),
      else: $ error("unclosedObject", line: tokens @ entriesEnd |.line, column: tokens @ entriesEnd |.column),
    )
  )
);

parseObjectElements = (tokens, index, entries, tracer: = dummyTracer) => (
  if(
    tokens @ index |.type | eq("CLOSE_BRACE"),
    then: $ [entries, index],
    else: $ (
      [entry, entryEnd] = parseObjectElement(tokens, index, tracer:);
      if(
        tokens @ entryEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = entryEnd | add(1);
          parseObjectElements(tokens, commaEnd, entries | add(entry), tracer:)
        ),
        else: $ [entries | add(entry), entryEnd],
      )
    ),
  )
);

parseObjectElement = (tokens, index, tracer: = dummyTracer) => (
  token = tokens @ index;
  if(
    token.type | eq("DOUBLE_STAR"),
    then: $ (
      starEnd = index | add(1);
      [value, valueEnd] = parseAssignable(tokens, starEnd, tracer:);
      [{type: "objectSpread", value: value}, valueEnd]
    ),
    else: $ if(
      tokens @ (index | add(1)) |.type | eq("COLON"),
      then: $ (
        [key, keyEnd] = parseAssignable(tokens, index, tracer:);
        colonEnd = keyEnd | add(1);
        [value, valueEnd] = parseAssignable(tokens, colonEnd, tracer:);
        [{type: "entry", key: key, value: value}, valueEnd]
      ),
      else: $ (
        [name, nameEnd] = parseName(tokens, index, tracer:);
        if(
          tokens @ nameEnd |.type | eq("COLON"),
          then: $ (
            colonEnd = nameEnd | add(1);
            [value, valueEnd] = parseAssignable(tokens, colonEnd, tracer:);
            [{type: "entry", key: {type: "keyName", key: name}, value: value}, valueEnd]
          ),
          else: $ (
            [{type: "keyName", key: name}, nameEnd]
          ),
        )
      ),
    ),
  )
);

parseLiteral = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "literal",
  $ (
    token = tokens @ index;
    literalEnd = index | add(1);
    tracer.log(
      ["Matched literal ", token.value | display, " at ", index | display]
      | join
    );
    [{type: "literal", value: token.value}, literalEnd]
  )
);

parseConstantFunction = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "constantFunction",
  $ (
    dollarEnd = index | add(1);
    [body, bodyEnd] = parseAssignable(tokens, dollarEnd, tracer:);
    [{type: "constantFunction", body: body}, bodyEnd]
  )
);

parseName = (tokens, index, tracer: = dummyTracer) => tracer.inBlock(
  "name",
  $ (
    token = tokens @ index;
    if(
      token.type | eq("NAME"),
      then: $ (
        nameStart = index | add(1);
        if(
          tokens @ nameStart |.type | eq("SLASH"),
          then: $ (
            moduleName = token.text;
            slashEnd = nameStart | add(1);
            nameToken = tokens @ slashEnd;
            if(
              nameToken.type | eq("NAME"),
              then: $ (
                nameEnd = slashEnd | add(1);
                [{type: "name", name: nameToken.text, from: moduleName}, nameEnd]
              ),
              else: $ error("expectedNameInModule", line: nameToken.line, column: nameToken.column),
            )
          ),
          else: $ [{type: "name", name: token.text}, nameStart],
        )
      ),
      else: $ error("expectedName", line: token.line, column: token.column),
    )
  )
);

parseArgumentList = (tokens, index, tracer: = dummyTracer) => (
  token = tokens @ index;
  if(
    token.type | eq("OPEN_PAREN"),
    then: $ (
      parenStart = index | add(1);
      [args, argsEnd] = parseArguments(tokens, parenStart, [], tracer:);
      if(
        tokens @ argsEnd |.type | eq("CLOSE_PAREN"),
        then: $ (
          parenEnd = argsEnd | add(1);
          [{type: "mixedArgList", args: args}, parenEnd]
        ),
        else: $ error("unclosedArguments", line: tokens @ argsEnd |.line, column: tokens @ argsEnd |.column),
      )
    ),
    else: $ error("expectedArguments", line: token.line, column: token.column),
  )
);

parseArguments = (tokens, index, args, tracer: = dummyTracer) => (
  if(
    tokens @ index |.type | eq("CLOSE_PAREN"),
    then: $ [args, index],
    else: $ (
      [arg, argEnd] = parseArgument(tokens, index, tracer:);
      if(
        tokens @ argEnd |.type | eq("COMMA"),
        then: $ (
          commaEnd = argEnd | add(1);
          parseArguments(tokens, commaEnd, args | add(arg), tracer:)
        ),
        else: $ [args | add(arg), argEnd],
      )
    ),
  )
);

parseArgument = (tokens, index) => (
  token = tokens @ index;
  if(
    token.type | eq("STAR"),
    then: $ (
      starEnd = index | add(1);
      [value, valueEnd] = parseAssignable(tokens, starEnd);
      [{type: "arraySpread", value: value}, valueEnd]
    ),
    else: $ if(
      token.type | eq("DOUBLE_STAR"),
      then: $ (
        starEnd = index | add(1);
        [value, valueEnd] = parseAssignable(tokens, starEnd);
        [{type: "objectSpread", value: value}, valueEnd]
      ),
      else: $ if(
        tokens @ (index | add(1)) |.type | eq("COLON"),
        then: $ (
          [key, keyEnd] = parseAssignable(tokens, index);
          colonEnd = keyEnd | add(1);
          [value, valueEnd] = parseAssignable(tokens, colonEnd);
          [{type: "entry", key: key, value: value}, valueEnd]
        ),
          else: $ if(
            token.type | eq("NAME") | and($ tokens @ (index | add(1)) |.type | eq("COLON")),
            then: $ (
              [name, nameEnd] = parseName(tokens, index);
              colonEnd = nameEnd | add(1);
              [value, valueEnd] = parseAssignable(tokens, colonEnd);
              [{type: "entry", key: {type: "keyName", key: name}, value: value}, valueEnd]
            ),
          else: $ parseAssignable(tokens, index),
        ),
      ),
    ),
  )
);

error = (type, line:, column:, **properties) => (
  throw(newError(type, line:, column:, **properties))
);
